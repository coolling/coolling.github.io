<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coolling</title>
  
  
  <link href="https://coolling.github.io/atom.xml" rel="self"/>
  
  <link href="https://coolling.github.io/"/>
  <updated>2024-09-21T11:13:46.470Z</updated>
  <id>https://coolling.github.io/</id>
  
  <author>
    <name>Coolling</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>滑动窗口</title>
    <link href="https://coolling.github.io/2024/09/21/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>https://coolling.github.io/2024/09/21/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2024-09-21T10:57:34.000Z</published>
    <updated>2024-09-21T11:13:46.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong>的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我感觉滑动窗口貌似和双指针有点像。枚举从每一个位置开始的最长不重复子串，而后一个位置可以利用前一个位置的结果：即将前一个位置的字符删掉，接着往下查探。</p><p>学到：unordered_set</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=<span class="number">-1</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; occ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;size;l++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l!=<span class="number">0</span>)&#123;</span><br><span class="line">                occ.<span class="built_in">erase</span>(s[l<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r+<span class="number">1</span>&lt;size&amp;&amp;!occ.<span class="built_in">count</span>(s[r+<span class="number">1</span>]))&#123;</span><br><span class="line">                occ.<span class="built_in">insert</span>(s[r+<span class="number">1</span>]);</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(re&lt;r-l+<span class="number">1</span>)&#123;</span><br><span class="line">                re=r-l+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 </p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这道题还是挺直观的，大概直觉就是在每个位置取s2个字母看看是不是和p一样。区别在于如何更快地比较。</p><p>为了忽略顺序，将字符存在vector<int>数组，每次比较数组是否相同。而窗口的滑动对应数组的删改也很容易，将前一个字符对应的位置–，后一个字符对应的位置++</p><p>学到：本来还想用上一题学到的unordered_set，但是unordered_set比较的时间复杂度是O(n2)。虽然抛开时间复杂度，我一开始没意识到，使用unordered_set进行解题也没通过…..菜鸡爆哭.jpg 不知道unordered_set的比较是不是有什么坑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">        <span class="type">int</span> s1=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> s2=p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(s1&lt;s2)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ss</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ps</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s2;i++)&#123;</span><br><span class="line">            ss[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            ps[p[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ss==ps)&#123;</span><br><span class="line">            re.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1-s2;i++)&#123;</span><br><span class="line">            ss[s[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            ss[s[i+s2]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(ss==ps)&#123;</span><br><span class="line">                </span><br><span class="line">                re.<span class="built_in">emplace_back</span>(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;滑动窗口&quot;&gt;&lt;a href=&quot;#滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口&quot;&gt;&lt;/a&gt;滑动窗口&lt;/h1&gt;&lt;h2 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="滑动窗口" scheme="https://coolling.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>双指针1</title>
    <link href="https://coolling.github.io/2024/09/16/%E5%8F%8C%E6%8C%87%E9%92%881/"/>
    <id>https://coolling.github.io/2024/09/16/%E5%8F%8C%E6%8C%87%E9%92%881/</id>
    <published>2024-09-16T08:59:44.000Z</published>
    <updated>2024-09-16T09:11:56.747Z</updated>
    
    <content type="html"><![CDATA[<p>#算法题-双指针</p><p>来自<strong>LeetCode 热题 100</strong></p><p>##移动零</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这个题我的思路不是双指针，大概的思路是：遍历的时候记录前面有几个0，就意味着这个数字应该往前再移动几位。最后再将末尾的部分置为0.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i-j]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=size-j;i&lt;size;i++)&#123;</span><br><span class="line">            nums[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>官方题解是设了两个指针，在l之前的都是不为0，r之后的是未处理的，l和r之间的都为0。这样每次r遇到非0，就和l交换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/move-zeroes/solutions/489622/yi-dong-ling-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>##盛最多水的容器</p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>好像是一道很经典的双指针题目，两个指针一开始分别指向两端，这个时候应该先移动哪个指针呢？因为木桶短板原理，这个时候容积由短的那一端决定。如果想提升容积，只能移动较低的那一端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size=height.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=size<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">            <span class="type">int</span> t=<span class="built_in">min</span>(height[l],height[r]);</span><br><span class="line">            <span class="keyword">if</span>((r-l)*t&gt;re)&#123;</span><br><span class="line">                re=(r-l)*t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(height[l]&gt;height[r])&#123;</span><br><span class="line">                r=r<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l=l+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#算法题-双指针&lt;/p&gt;
&lt;p&gt;来自&lt;strong&gt;LeetCode 热题 100&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##移动零&lt;/p&gt;
&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="双指针" scheme="https://coolling.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>哈希</title>
    <link href="https://coolling.github.io/2024/09/08/%E5%93%88%E5%B8%8C/"/>
    <id>https://coolling.github.io/2024/09/08/%E5%93%88%E5%B8%8C/</id>
    <published>2024-09-08T07:50:23.000Z</published>
    <updated>2024-09-08T08:20:23.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法题-哈希"><a href="#算法题-哈希" class="headerlink" title="算法题-哈希"></a>算法题-哈希</h1><p>来自<strong>LeetCode 热题 100</strong></p><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将值全存到hash表中，然后枚举每个数，判断target-num在不在hash表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="type">int</span> size=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            m[nums[i]]=i;</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it=m.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(it!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">             </span><br><span class="line">                <span class="keyword">if</span>(i!=it-&gt;second)&#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    result.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p><strong>应该用unordered_map的，它内部是hash表，操作的复杂度是O(1)，而map底层是红黑树，操作的复杂度是O(lgn)</strong></p><p>代码也可以写得更简洁一些，边找边存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/two-sum/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>在查找和存之前，先对字符串进行排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string,vector&lt;string&gt;&gt; m;</span><br><span class="line">        <span class="type">int</span> s = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">            string t = strs[i];</span><br><span class="line">            <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> it=m.<span class="built_in">find</span>(t);</span><br><span class="line">            <span class="keyword">if</span>(it!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">// printf(&quot;%s\n&quot;,t.c_str());</span></span><br><span class="line">                it-&gt;second.<span class="built_in">emplace_back</span>(strs[i]);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m[t]=&#123;strs[i]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> iterator = m.<span class="built_in">begin</span>();</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span>(iterator!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">            result.<span class="built_in">emplace_back</span>(iterator-&gt;second);</span><br><span class="line">            iterator++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h3><p>一开始用的是push_back，它和emplace_back的区别是，push_back直接将对象复制到容器，而emplace_back是传递参数，调用对象的构造函数创建对象，后者减少了内存之间的移动</p><p>尝试用 for (string&amp; str: strs)这个写法简洁些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; str: strs) &#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            mp[key].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>在我感觉，这个题有一点像是图遍历，有一点像是找到所有子图，返回最大的子图的节点数。看似有两层循环，但是每个节点只被访问一次，实际上复杂度是O(n)。</p><p>其中hash表的存在，在里面的作用是：快速判断是否有边；判断是否被访问过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            m[num]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(m[num]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> num1=num;</span><br><span class="line">                <span class="keyword">while</span>(m.<span class="built_in">find</span>(num1)!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    t++;</span><br><span class="line">                    m.<span class="built_in">find</span>(num1)-&gt;second=<span class="number">1</span>;</span><br><span class="line">                    num1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> num2=num<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(m.<span class="built_in">find</span>(num2)!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    t++;</span><br><span class="line">                    m.<span class="built_in">find</span>(num2)-&gt;second=<span class="number">1</span>;</span><br><span class="line">                    num2--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t&gt;re)&#123;</span><br><span class="line">                    re=t;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不足-2"><a href="#不足-2" class="headerlink" title="不足"></a>不足</h3><p>和官方题解虽然写法不同，但是其实是一个意思。</p><p>for (const int&amp; num : num_set)。这种写法避免了对变量的修改（const），也避免了不必要的拷贝（&amp;）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : nums) &#123;</span><br><span class="line">            num_set.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> longestStreak = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : num_set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!num_set.<span class="built_in">count</span>(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> currentNum = num;</span><br><span class="line">                <span class="type">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (num_set.<span class="built_in">count</span>(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentStreak += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                longestStreak = <span class="built_in">max</span>(longestStreak, currentStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longestStreak;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/longest-consecutive-sequence/solutions/276931/zui-chang-lian-xu-xu-lie-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法题-哈希&quot;&gt;&lt;a href=&quot;#算法题-哈希&quot; class=&quot;headerlink&quot; title=&quot;算法题-哈希&quot;&gt;&lt;/a&gt;算法题-哈希&lt;/h1&gt;&lt;p&gt;来自&lt;strong&gt;LeetCode 热题 100&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;两数之和&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="哈希" scheme="https://coolling.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://coolling.github.io/2024/09/05/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://coolling.github.io/2024/09/05/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2024-09-05T08:01:37.000Z</published>
    <updated>2024-09-05T08:15:28.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><strong>管道类似于文件重定向，可以将前一个命令的stdout重定向到下一个命令的stdin。</strong></p><p>要点</p><blockquote><p>管道命令仅处理stdout，会忽略stderr。<br>管道右边的命令必须能接受stdin。<br>多个管道命令可以串联。</p></blockquote><p>与文件重定向的区别</p><blockquote><p>文件重定向左边为命令，右边为文件。<br>管道左右两边均为命令，左边有stdout，右边有stdin。</p></blockquote><p>举例</p><blockquote><p>find . -name ‘*.py’ | xargs cat | wc -l</p></blockquote><h2 id="系统状况"><a href="#系统状况" class="headerlink" title="系统状况"></a>系统状况</h2><ol><li><p>top：查看所有进程的信息（Linux的任务管理器）</p><blockquote><p>打开后，输入M：按使用内存排序</p><p>打开后，输入P：按使用CPU排序</p><p>打开后，输入q：退出</p></blockquote></li><li><p>df -h：查看硬盘使用情况</p></li><li><p>free -h：查看内存使用情况</p></li><li><p>du -sh：查看当前目录占用的硬盘空间</p></li><li><p>ps aux：查看所有进程</p></li><li><p>kill -9 pid：杀死编号为pid的进程</p><blockquote><p>传递某个具体的信号：kill -s SIGTERM pid</p></blockquote></li><li><p>netstat -nt：查看所有网络连接</p></li><li><p>w：列出当前登陆的用户</p></li><li><p>ping <a href="http://www.baidu.com：检查是否连网">www.baidu.com：检查是否连网</a></p></li></ol><h2 id="常用文件管理命令"><a href="#常用文件管理命令" class="headerlink" title="常用文件管理命令"></a>常用文件管理命令</h2><ol><li><p>ctrl c: 取消命令，并且换行</p></li><li><p>ctrl u: 清空本行命令</p></li><li><p>tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p></li><li><p>ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p></li><li><p>pwd: 显示当前路径</p></li><li><p>cd XXX: 进入XXX目录下, cd .. 返回上层目录</p></li><li><p>cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如..&#x2F;dir_c&#x2F;a.txt，表示上层目录下的dir_c文件夹下的文件a.txt</p></li><li><p>mkdir XXX: 创建目录XXX</p></li><li><p>rm XXX: 删除普通文件;  rm XXX -r: 删除文件夹</p></li><li><p>mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令</p></li><li><p>touch XXX: 创建一个文件</p></li><li><p>cat XXX: 展示文件XXX中的内容</p></li></ol><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>chmod：修改文件权限</p><blockquote><p>chmod +x xxx：给xxx添加可执行权限<br>chmod -x xxx：去掉xxx的可执行权限<br>chmod 777 xxx：将xxx的权限改成777<br>chmod 777 xxx -R：递归修改整个文件夹的权限</p></blockquote><h2 id="文件检索"><a href="#文件检索" class="headerlink" title="文件检索"></a>文件检索</h2><ol><li><p>find &#x2F;path&#x2F;to&#x2F;directory&#x2F; -name ‘<em>.py’：搜索某个文件路径下的所有</em>.py文件</p></li><li><p>grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行；否则忽略该行。</p></li><li><p>wc：统计行数、单词数、字节数</p><p>既可以从stdin中直接读入内容；也可以在命令行参数中传入文件名列表；</p><blockquote><p>wc -l：统计行数</p><p>wc -w：统计单词数</p><p>wc -c：统计字节数</p></blockquote></li><li><p>tree：展示当前目录的文件结构</p><blockquote><p>tree &#x2F;path&#x2F;to&#x2F;directory&#x2F;：展示某个目录的文件结构</p><p>tree -a：展示隐藏文件</p></blockquote></li><li><p>ag xxx：搜索当前目录下的所有文件，检索xxx字符串</p></li><li><p>cut：分割一行内容</p><p>从stdin中读入多行数据</p><blockquote><p>echo $PATH | cut -d ‘:’ -f 3,5：输出PATH用:分割后第3、5列数据</p><p>echo $PATH | cut -d ‘:’ -f 3-5：输出PATH用:分割后第3-5列数据</p><p>echo $PATH | cut -c 3,5：输出PATH的第3、5个字符</p><p>echo $PATH | cut -c 3-5：输出PATH的第3-5个字符</p></blockquote></li><li><p>sort：将每行内容按字典序排序</p><p>可以从stdin中读取多行数据</p><p>可以从命令行参数中读取文件名列表</p></li><li><p>xargs：将stdin中的数据用空格或回车分割成命令行参数</p><blockquote><p>find . -name ‘*.py’ | xargs cat | wc -l：统计当前目录下所有python文件的总行数</p></blockquote></li></ol><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><ol><li><p>more：浏览文件内容</p><blockquote><p>回车：下一行</p><p>空格：下一页</p><p>b：上一页</p><p>q：退出</p></blockquote></li><li><p>less：与more类似，功能更全</p><blockquote><p>回车：下一行</p><p>y：上一行</p><p>Page Down：下一页</p><p>Page Up：上一页</p><p>q：退出</p></blockquote></li><li><p>head -3 xxx：展示xxx的前3行内容</p><p>同时支持从stdin读入内容</p></li><li><p>tail -3 xxx：展示xxx末尾3行内容</p><p>同时支持从stdin读入内容</p></li></ol><h2 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h2><ol><li>history：展示当前用户的历史操作。内容存放在~&#x2F;.bash_history中</li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><p>md5sum：计算md5哈希值</p><p>可以从stdin读入内容</p><p>也可以在命令行参数中传入文件名列表；</p></li><li><p>time command：统计command命令的执行时间</p></li><li><p>ipython3：交互式python3环境。可以当做计算器，或者批量管理文件。</p><blockquote><p>! echo “Hello World”：!表示执行shell脚本</p></blockquote></li><li><p>watch -n 0.1 command：每0.1秒执行一次command命令</p></li><li><p>tar：压缩文件</p><p>tar -zcvf xxx.tar.gz &#x2F;path&#x2F;to&#x2F;file&#x2F;*：压缩</p><p>tar -zxvf xxx.tar.gz：解压缩</p></li><li><p>diff xxx yyy：查找文件xxx与yyy的不同点</p></li></ol><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><ol><li>sudo command：以root身份执行command命令</li><li>apt-get install xxx：安装软件</li><li>pip install xxx –user –upgrade：安装python包</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux常用命令&quot;&gt;&lt;a href=&quot;#Linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令&quot;&gt;&lt;/a&gt;Linux常用命令&lt;/h1&gt;&lt;h2 id=&quot;管道&quot;&gt;&lt;a href=&quot;#管道&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="linux基础" scheme="https://coolling.github.io/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux常用命令" scheme="https://coolling.github.io/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="https://coolling.github.io/2024/08/31/git/"/>
    <id>https://coolling.github.io/2024/08/31/git/</id>
    <published>2024-08-31T10:44:39.000Z</published>
    <updated>2024-08-31T10:46:46.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h1><h2 id="git基本概念"><a href="#git基本概念" class="headerlink" title="git基本概念"></a>git基本概念</h2><ul><li>工作区：仓库的目录。工作区是独立于各个分支的。</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中每个节点代表一个代码版本。</li></ul><h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><ol><li>git config –global user.name xxx：设置全局用户名，信息记录在~&#x2F;.gitconfig文件中</li><li>git config –global user.email <a href="mailto:&#120;&#x78;&#x78;&#64;&#120;&#x78;&#120;&#46;&#x63;&#x6f;&#109;">&#120;&#x78;&#x78;&#64;&#120;&#x78;&#120;&#46;&#x63;&#x6f;&#109;</a>：设置全局邮箱地址，信息记录在~&#x2F;.gitconfig文件中</li><li>git init：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中</li><li>git add XX：将XX文件添加到暂存区</li><li>git add .：将所有待加入暂存区的文件加入暂存区</li><li>git rm –cached XX：将文件从仓库索引目录中删掉</li><li>git commit -m “给自己看的备注信息”：将暂存区的内容提交到当前分支</li><li>git status：查看仓库状态</li><li>git diff XX：查看XX文件相对于暂存区修改了哪些内容</li><li>git log：查看当前分支的所有版本</li><li>git reflog：查看HEAD指针的移动历史（包括被回滚的版本）</li><li>git reset –hard HEAD^ 或 git reset –hard HEAD~：将代码库回滚到上一个版本</li><li>git reset –hard HEAD^^：往上回滚两次，以此类推</li><li>git reset –hard HEAD~100：往上回滚100个版本</li><li>git reset –hard 版本号：回滚到某一特定版本</li><li>git checkout — XX或git restore XX：将XX文件尚未加入暂存区的修改全部撤销</li><li>git remote add origin <a href="mailto:&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#x2e;&#x61;&#x63;&#x77;&#x69;&#110;&#x67;&#46;&#x63;&#111;&#x6d;">&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#x2e;&#x61;&#x63;&#x77;&#x69;&#110;&#x67;&#46;&#x63;&#111;&#x6d;</a>:xxx&#x2F;XXX.git：将本地仓库关联到远程仓库</li><li>git push -u (第一次需要-u以后不需要)：将当前分支推送到远程仓库</li><li>git push origin branch_name：将本地的某个分支推送到远程仓库</li><li>git clone <a href="mailto:&#103;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#46;&#97;&#x63;&#119;&#x69;&#110;&#103;&#x2e;&#99;&#111;&#x6d;">&#103;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#46;&#97;&#x63;&#119;&#x69;&#110;&#103;&#x2e;&#99;&#111;&#x6d;</a>:xxx&#x2F;XXX.git：将远程仓库XXX下载到当前目录下</li><li>git checkout -b branch_name：创建并切换到branch_name这个分支</li><li>git branch：查看所有分支和当前所处分支</li><li>git checkout branch_name：切换到branch_name这个分支</li><li>git merge branch_name：将分支branch_name合并到当前分支上</li><li>git branch -d branch_name：删除本地仓库的branch_name分支</li><li>git branch branch_name：创建新分支</li><li>git push –set-upstream origin branch_name：设置本地的branch_name分支对应远程仓库的branch_name分支</li><li>git push -d origin branch_name：删除远程仓库的branch_name分支</li><li>git pull：将远程仓库的当前分支与本地仓库的当前分支合并</li><li>git pull origin branch_name：将远程仓库的branch_name分支与本地仓库的当前分支合并</li><li>git branch –set-upstream-to&#x3D;origin&#x2F;branch_name1 branch_name2：将远程的branch_name1分支与本地的branch_name2分支对应</li><li>git checkout -t origin&#x2F;branch_name 将远程的branch_name分支拉取到本地</li><li>git stash：将工作区和暂存区中尚未提交的修改存入栈中</li><li>git stash apply：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</li><li>git stash drop：删除栈顶存储的修改</li><li>git stash pop：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</li><li>git stash list：查看栈中所有元素</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git使用&quot;&gt;&lt;a href=&quot;#git使用&quot; class=&quot;headerlink&quot; title=&quot;git使用&quot;&gt;&lt;/a&gt;git使用&lt;/h1&gt;&lt;h2 id=&quot;git基本概念&quot;&gt;&lt;a href=&quot;#git基本概念&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="linux基础" scheme="https://coolling.github.io/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="git" scheme="https://coolling.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>ssh常用命令</title>
    <link href="https://coolling.github.io/2024/08/28/ssh%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://coolling.github.io/2024/08/28/ssh%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2024-08-28T14:14:34.000Z</published>
    <updated>2024-08-28T14:40:26.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSH基本用法"><a href="#SSH基本用法" class="headerlink" title="SSH基本用法"></a>SSH基本用法</h1><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><h3 id="远程登录服务器"><a href="#远程登录服务器" class="headerlink" title="远程登录服务器"></a>远程登录服务器</h3><p><strong>1.ssh user@hostname</strong></p><blockquote><p>user: 用户名<br>hostname: IP地址或域名</p></blockquote><p><strong>2.第一次登录时会提示：</strong></p><blockquote><p>The authenticity of host ‘123.57.47.211 (123.57.47.211)’ can’t be established.<br>ECDSA key fingerprint is SHA256:iy237yysfCe013&#x2F;l+kpDGfEG9xxHxm0dnxnAbJTPpG8.<br>Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])?</p></blockquote><p>输入yes，然后回车即可。<br>这样会将该服务器的信息记录在~&#x2F;.ssh&#x2F;known_hosts文件中。</p><p>然后输入密码即可登录到远程服务器中。</p><p><strong>3.默认登录端口号为22</strong>。如果想登录某一特定端口：</p><blockquote><p>ssh user@hostname -p 22</p></blockquote><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><strong>1.创建文件 ~&#x2F;.ssh&#x2F;config。</strong></p><p><strong>2.然后在文件中输入：</strong></p><blockquote><p>Host myserver1<br>    HostName IP地址或域名<br>    User 用户名</p><p>Host myserver2<br>    HostName IP地址或域名<br>    User 用户名</p></blockquote><p><strong>3.之后再使用服务器时，可以直接使用别名myserver1、myserver2。</strong></p><h3 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h3><p><strong>1.创建密钥：</strong></p><blockquote><p>ssh-keygen</p></blockquote><p>然后一直回车即可。</p><p>执行结束后，~&#x2F;.ssh&#x2F;目录下会多两个文件：</p><blockquote><p>id_rsa：私钥<br>id_rsa.pub：公钥</p></blockquote><p><strong>2.之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。</strong></p><p>例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的~&#x2F;.ssh&#x2F;authorized_keys文件里即可。</p><p><strong>3.也可以使用如下命令一键添加公钥：</strong></p><blockquote><p>ssh-copy-id myserver</p></blockquote><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>命令格式：</p><blockquote><p>ssh user@hostname command</p></blockquote><p>例如：</p><blockquote><p>ssh user@hostname ls -a</p></blockquote><h2 id="SCP"><a href="#SCP" class="headerlink" title="SCP"></a>SCP</h2><p><strong>1.将source路径下的文件复制到destination中：</strong></p><blockquote><p>scp source destination</p></blockquote><p><strong>2.一次复制多个文件：</strong></p><blockquote><p>scp source1 source2 destination</p></blockquote><p><strong>3.复制文件夹：</strong></p><blockquote><p>scp -r ~&#x2F;tmp myserver:&#x2F;home&#x2F;acs&#x2F;<br>将本地家目录中的tmp文件夹复制到myserver服务器中的&#x2F;home&#x2F;acs&#x2F;目录下。</p></blockquote><blockquote><p>scp -r <del>&#x2F;tmp myserver:homework&#x2F;<br>将本地家目录中的tmp文件夹复制到myserver服务器中的</del>&#x2F;homework&#x2F;目录下。</p></blockquote><blockquote><p>scp -r myserver:homework .<br>将myserver服务器中的~&#x2F;homework&#x2F;文件夹复制到本地的当前路径下。</p></blockquote><p><strong>4.指定服务器的端口号：</strong></p><blockquote><p>scp -P 22 source1 source2 destination</p></blockquote><p>注意： scp的-r -P等参数尽量加在source和destination之前。</p><p><strong>5.使用scp配置其他服务器的vim和tmux</strong></p><blockquote><p>scp ~&#x2F;.vimrc ~&#x2F;.tmux.conf myserver:</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSH基本用法&quot;&gt;&lt;a href=&quot;#SSH基本用法&quot; class=&quot;headerlink&quot; title=&quot;SSH基本用法&quot;&gt;&lt;/a&gt;SSH基本用法&lt;/h1&gt;&lt;h2 id=&quot;SSH&quot;&gt;&lt;a href=&quot;#SSH&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="linux基础" scheme="https://coolling.github.io/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="ssh" scheme="https://coolling.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>vim使用</title>
    <link href="https://coolling.github.io/2024/08/14/vim%E4%BD%BF%E7%94%A8/"/>
    <id>https://coolling.github.io/2024/08/14/vim%E4%BD%BF%E7%94%A8/</id>
    <published>2024-08-14T14:57:31.000Z</published>
    <updated>2024-08-14T14:59:49.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim使用"><a href="#vim使用" class="headerlink" title="vim使用"></a>vim使用</h1><pre><code>        功能：        (1) 命令行模式下的文本编辑器。        (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。        (3) 使用方式：vim filename            如果已有该文件，则打开它。            如果没有该文件，则打开个一个新的文件，并命名为filename    模式：        (1) 一般命令模式            默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。        (2) 编辑模式            在一般命令模式里按下i，会进入编辑模式。            按下ESC会退出编辑模式，返回到一般命令模式。        (3) 命令行模式            在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。            可以查找、替换、保存、退出、配置编辑器等。    操作：        (1) i：进入辑模式        (2) ESC：进入一般命令模式        (3) h 或 左箭头键：光标向左移动一个字符        (4) j 或 向下箭头：光标向下移动一个字符        (5) k 或 向上箭头：光标向上移动一个字符        (6) l 或 向右箭头：光标向右移动一个字符        (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符        (8) 0 或 功能键[Home]：光标移动到本行开头        (9) $ 或 功能键[End]：光标移动到本行末尾        (10) G：光标移动到最后一行        (11) :n 或 nG：n为数字，光标移动到第n行        (12) gg：光标移动到第一行，相当于1G        (13) n&lt;Enter&gt;：n为数字，光标向下移动n行        (14) /word：向光标之下寻找第一个值为word的字符串。        (15) ?word：向光标之上寻找第一个值为word的字符串。        (16) n：重复前一个查找操作        (17) N：反向重复前一个查找操作        (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2        (19) :1,$s/word1/word2/g：将全文的word1替换为word2        (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。        (21) v：选中文本        (22) d：删除选中的文本        (23) dd: 删除当前行        (24) y：复制选中的文本        (25) yy: 复制当前行        (26) p: 将复制的数据在光标的下一行/下一个位置粘贴        (27) u：撤销        (28) Ctrl + r：取消撤销        (29) 大于号 &gt;：将选中的文本整体向右缩进一次        (30) 小于号 &lt;：将选中的文本整体向左缩进一次        (31) :w 保存        (32) :w! 强制保存        (33) :q 退出        (34) :q! 强制退出        (35) :wq 保存并退出        (36) :set paste 设置成粘贴模式，取消代码自动缩进        (37) :set nopaste 取消粘贴模式，开启代码自动缩进        (38) :set nu 显示行号        (39) :set nonu 隐藏行号        (40) gg=G：将全文代码格式化        (41) :noh 关闭查找关键词高亮        (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令    异常处理：        每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。        如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：            (1) 找到正在打开该文件的程序，并退出            (2) 直接删掉该swp文件即可</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vim使用&quot;&gt;&lt;a href=&quot;#vim使用&quot; class=&quot;headerlink&quot; title=&quot;vim使用&quot;&gt;&lt;/a&gt;vim使用&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;        功能：
        (1) 命令行模式下的文本编辑器。
        (2) </summary>
      
    
    
    
    <category term="linux基础" scheme="https://coolling.github.io/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="vim" scheme="https://coolling.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>tmux使用</title>
    <link href="https://coolling.github.io/2024/08/14/tmux%E4%BD%BF%E7%94%A8/"/>
    <id>https://coolling.github.io/2024/08/14/tmux%E4%BD%BF%E7%94%A8/</id>
    <published>2024-08-14T14:47:23.000Z</published>
    <updated>2024-08-14T14:49:48.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tmux使用"><a href="#tmux使用" class="headerlink" title="tmux使用"></a>tmux使用</h1><pre><code>功能：    (1) 分屏。    (2) 允许断开Terminal连接后，继续运行进程。结构：    一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。    实例：        tmux:            session 0:                window 0:                    pane 0                    pane 1                    pane 2                    ...                window 1                window 2                ...            session 1            session 2            ...操作：    (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。    (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。    (3) 按下Ctrl + a后手指松开，然后按&quot;：将当前pane上下平分成两个pane。    (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。    (5) 鼠标点击可以选pane。    (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。    (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。    (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。    (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。    (10) 按下ctrl + a后手指松开，然后按d：挂起当前session。    (11) tmux a：打开之前挂起的session。    (12) 按下ctrl + a后手指松开，然后按s：选择其它session。        方向键 —— 上：选择上一项 session/window/pane        方向键 —— 下：选择下一项 session/window/pane        方向键 —— 右：展开当前项 session/window        方向键 —— 左：闭合当前项 session/window    (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。    (14) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。    (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。    (16) 鼠标滚轮：翻阅当前pane内的内容。    (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）    (18) tmux中复制/粘贴文本的通用方式：        (1) 按下Ctrl + a后松开手指，然后按[        (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板        (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tmux使用&quot;&gt;&lt;a href=&quot;#tmux使用&quot; class=&quot;headerlink&quot; title=&quot;tmux使用&quot;&gt;&lt;/a&gt;tmux使用&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;功能：
    (1) 分屏。
    (2) 允许断开Terminal连接后，继续运行进程</summary>
      
    
    
    
    <category term="linux基础" scheme="https://coolling.github.io/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="tmux" scheme="https://coolling.github.io/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>NSDI24-Parcae</title>
    <link href="https://coolling.github.io/2024/05/19/NSDI24-Parcae/"/>
    <id>https://coolling.github.io/2024/05/19/NSDI24-Parcae/</id>
    <published>2024-05-19T14:13:03.000Z</published>
    <updated>2024-05-19T14:25:56.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Parcae-Proactive-Liveput-Optimized-DNN-Training-on-Preemptible-Instances"><a href="#Parcae-Proactive-Liveput-Optimized-DNN-Training-on-Preemptible-Instances" class="headerlink" title="Parcae: Proactive, Liveput-Optimized DNN Training on Preemptible Instances"></a>Parcae: Proactive, Liveput-Optimized DNN Training on Preemptible Instances</h1><p>nsdi24</p><p>针对抢占式实例进行主动、Liveput 优化的 DNN 训练</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>dnn越来越大–》训练越来越贵–》使用spot可抢占实例（低90%的价格）–》但是随时会被抢占怎么办</p><p><strong>以前的方法</strong></p><p>1.检查点：<strong>抢占频率</strong>高，检查点不适合</p><p>2.反应式，如bamboo 性能和可扩展性有限。很难通过管道气泡完全隐藏<strong>冗余计算的开销</strong>，特别是大模型。并且<strong>增加内存消耗</strong>，bamboo通过增加流水线深度来解决，但是这样会导致计算效率降低</p><h2 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h2><p><strong>parcae</strong>：主动式，在抢占之前预测资源变化，主动调整并行度</p><p><strong>新指标</strong>：<strong>liveput</strong>，测量dnn作业在各种抢占场景下的预期训练吞吐量。</p><p>（同时考虑了并行配置的吞吐量及其在抢占情况下的鲁棒性）</p><p><strong>parcae的关键见解：并行dnn训练的不同策略在抢占情况下表现出不同的鲁棒性。</strong></p><p>更长的流水线可以获得更高的吞吐量但更容易遭到抢占</p><p><img src="/../images/Parcae/parcae1.png" alt="img"></p><p><strong>如何预测？如何处理抢占？如何选择最佳并行配置？</strong></p><p>1.实例的抢占是不可知的，parcase使用两级方法来粗粒度地预测所有实例的可用性。</p><p>a.使用一个可用性预测器：输入实例的抢占和分配历史，预测近期可用实例的数量</p><p>b.蒙特卡洛抢占采样器使用预测的实例可用性对抢占进行采样</p><p>2.parcae使用轻量级实时迁移机制来处理抢占允许dnn训练在丢失实例的情况下继续进行</p><p>在每次迭代使用相同数量的样本更新模型参数，并机会性地重新排序样本来避免冗余计算或重新启动训练</p><p>3.liveput优化器将最大化liveput的问题表述为优化问题，使用新颖的动态规划算法来探索并行配置的搜索空间。</p><p><img src="/../images/Parcae/parcae2.png" alt="img"></p><h2 id="liveput指标"><a href="#liveput指标" class="headerlink" title="liveput指标"></a>liveput指标</h2><p>训练作业的liveup是其在所有可能的抢占场景下的期望吞吐量</p><p>D：数据并行数量</p><p>P：流水线阶段数目</p><p>V：抢占场景的概率分布</p><p><img src="/../images/Parcae/parcae3.png" alt="img"></p><p>V是一个D*P维的0 1向量，vk&#x3D;1代表第k个实例被抢占。其中的吞吐量计算是指发生v抢占后的新并行配置的吞吐量</p><p><strong>liveput指标和吞吐量指标的差异</strong></p><p>优势：它考虑了并行配置的性能在不同抢占场景下的变化</p><p><img src="/../images/Parcae/parcae4.png" alt="img"></p><p>吞吐量不考虑抢占的情况，因此任何场景下上图第一个都优于第二个。</p><p>较长的管道更容易受到抢占，因为单个抢占将使小批次内的这个管道失效，较短的管道在频繁的抢占下表现出更好的弹性和复原力。</p><h2 id="Parcae概述"><a href="#Parcae概述" class="headerlink" title="Parcae概述"></a>Parcae概述</h2><p><img src="/../images/Parcae/parcae5.png" alt="img"></p><p>1.使用两级方法粗粒度地预测所有实例的可用性</p><p>预测未来可用实例的数量，使用预测的可用性对抢占和分配进行采样</p><p>2.将预测的实例可用性作为输入，发现最大化liveput的并行配置</p><p>3.parcae使用3个实时迁移策略，减少开销</p><h2 id="可用性预测器"><a href="#可用性预测器" class="headerlink" title="可用性预测器"></a>可用性预测器</h2><p>1.单个实例的可用性不可预测</p><p>2.统计可用性预测</p><p>唯一可见且可靠的信息是当前用户提交的训练作业的过去抢占&#x2F;分配记录。</p><p><strong>预测的是可获得的实例数量</strong></p><p>使用过去H个时刻的可用实例数目作为输入，预测未来的可用实例数目</p><p>选择一个轻量级的自回归积分移动平均（ARIMA）算法进行预测。</p><p>从预测的可用实例数目，进一步推导出抢占或者分配数目（云不会同时分配和抢占同一个任务）</p><h2 id="实时迁移"><a href="#实时迁移" class="headerlink" title="实时迁移"></a>实时迁移</h2><p>给定抢占预测结果，Parcae可以提前安排有效的调整</p><p>1.实例抢占的影响很大程度取决于实例在数据并行和管道并行中的位置，但是在前一步的预测结果中并没有这些信息。</p><p>parcae使用概率模型来推理抢占事件到实际实例的映射</p><p><strong>抢占映射空间巨大</strong>？使用采样技术来探索映射空间并快速发现合理的准确近似值。Parcae 应用蒙特卡罗 (MC) 采样。</p><h3 id="迁移策略"><a href="#迁移策略" class="headerlink" title="迁移策略"></a>迁移策略</h3><p>三种迁移策略处理抢占：阶段内迁移、阶段间迁移和管道迁移</p><p><strong>阶段内迁移</strong>：同一阶段有相同的模型参数，当一个实例被抢占时，可以从另一个损坏的管道中的同一阶段转移可用实例</p><p><img src="/../images/Parcae/parcae6.png" alt="img"></p><p>阶段内迁移仅需更新少数实例的通信路由，并且不涉及传输参数。</p><p><strong>阶段间迁移</strong></p><p>如果阶段内迁移不行，进行阶段间迁移</p><p><img src="/../images/Parcae/parcae7.png" alt="img"></p><p>阶段间迁移需要传输模型参数</p><p><strong>管道迁移</strong></p><p><img src="/../images/Parcae/parcae8.png" alt="img"></p><p>需要重新划分模型，涉及大量的迁移开销</p><p>Parcae通过考虑当前并行配置、新的优化并行配置和实际抢占来作出迁移决策</p><p>给定预测抢占的概率映射，Parcae 自动更新最佳并行配置和迁移策略。一旦预测与实际可用性不匹配，Parcae 就会调整并行配置以及相应的迁移策略以进行适应</p><p>当抢占真正发生时，实际的迁移决策才会最终确定，Parcae 利用宽限期（例如，Azure 上的 30 秒）来执行这些迁移。</p><h2 id="liveput优化器"><a href="#liveput优化器" class="headerlink" title="liveput优化器"></a>liveput优化器</h2><p>将liveput最大化表述为一个优化问题，目标是最大化I时间间隔内的训练样本数</p><p>Parcae 使用动态规划算法来探索优化空间并发现并行配置的最佳序列</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>spot实例抢占与parcae预测不匹配怎么办？</p><p>建议的并行配置与可用spot实例不兼容怎么办？</p><p><strong>并行化适配</strong></p><p>当实际可用的spot实例数目大于或者小于预测的数目，parcae会添加或删除数据并行管道，同时保留管道深度。</p><p>当可用的spot实例甚至无法制定单个管道时，它将尝试将管道重新划分为更少的阶段。</p><p><strong>容错能力</strong></p><p>如果同一阶段内所有实例都被抢占，阶段间和阶段内迁移都无法恢复该阶段的状态，parcae使用内存检查点来处理。</p><p>使用多个便宜的按需cpu实例来维护最新的模型状态，通过迭代地将梯度与spot GPU 实例同步来维护最新的检查点，以更新CPU端的模型状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Parcae-Proactive-Liveput-Optimized-DNN-Training-on-Preemptible-Instances&quot;&gt;&lt;a href=&quot;#Parcae-Proactive-Liveput-Optimized-DNN-Training-</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://coolling.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="故障恢复" scheme="https://coolling.github.io/tags/%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/"/>
    
    <category term="NSDI" scheme="https://coolling.github.io/tags/NSDI/"/>
    
    <category term="24年" scheme="https://coolling.github.io/tags/24%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>2923. 找到冠军 I</title>
    <link href="https://coolling.github.io/2024/04/12/2923-%E6%89%BE%E5%88%B0%E5%86%A0%E5%86%9B-I/"/>
    <id>https://coolling.github.io/2024/04/12/2923-%E6%89%BE%E5%88%B0%E5%86%A0%E5%86%9B-I/</id>
    <published>2024-04-12T10:58:59.000Z</published>
    <updated>2024-04-12T11:06:02.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2923-找到冠军-I"><a href="#2923-找到冠军-I" class="headerlink" title="2923. 找到冠军 I"></a>2923. 找到冠军 I</h2><p>最近好忙，抽空摸一题</p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>一场比赛中共有 <code>n</code> 支队伍，按从 <code>0</code> 到 <code>n - 1</code> 编号。</p><p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n * n</code> 的二维布尔矩阵 <code>grid</code> 。对于满足 <code>0 &lt;= i, j &lt;= n - 1</code> 且 <code>i != j</code> 的所有 <code>i, j</code> ：如果 <code>grid[i][j] == 1</code>，那么 <code>i</code> 队比 <code>j</code> 队 <strong>强</strong> ；否则，<code>j</code> 队比 <code>i</code> 队 <strong>强</strong> 。</p><p>在这场比赛中，如果不存在某支强于 <code>a</code> 队的队伍，则认为 <code>a</code> 队将会是 <strong>冠军</strong> 。</p><p>返回这场比赛中将会成为冠军的队伍。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,1],[0,0]]</span><br><span class="line">输出：0</span><br><span class="line">解释：比赛中有两支队伍。</span><br><span class="line">grid[0][1] == 1 表示 0 队比 1 队强。所以 0 队是冠军。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,0,1],[1,0,1],[0,0,0]]</span><br><span class="line">输出：1</span><br><span class="line">解释：比赛中有三支队伍。</span><br><span class="line">grid[1][0] == 1 表示 1 队比 0 队强。</span><br><span class="line">grid[1][2] == 1 表示 1 队比 2 队强。</span><br><span class="line">所以 1 队是冠军。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>2 &lt;= n &lt;= 100</code></li><li><code>grid[i][j]</code> 的值为 <code>0</code> 或 <code>1</code></li><li>对于所有 <code>i</code>，<code> grid[i][i]</code> 等于 <code>0.</code></li><li>对于满足 <code>i != j</code> 的所有 <code>i, j</code> ，<code>grid[i][j] != grid[j][i]</code> 均成立</li><li>生成的输入满足：如果 <code>a</code> 队比 <code>b</code> 队强，<code>b</code> 队比 <code>c</code> 队强，那么 <code>a</code> 队比 <code>c</code> 队强</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>有两种方法：</p><p>1.遍历一遍grid矩阵，看看哪一行元素之和为n-1，这样的时间复杂度为O(n^2^)</p><p>2.打擂台的思想，一个个上去比较，最后留下来的赢家就是胜过所有人的，只需要遍历一遍n，时间复杂度为O(n)</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findChampion</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> win=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(grid[win][i]==<span class="number">0</span>)</span><br><span class="line">                win=i;</span><br><span class="line">        <span class="keyword">return</span> win;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2923-找到冠军-I&quot;&gt;&lt;a href=&quot;#2923-找到冠军-I&quot; class=&quot;headerlink&quot; title=&quot;2923. 找到冠军 I&quot;&gt;&lt;/a&gt;2923. 找到冠军 I&lt;/h2&gt;&lt;p&gt;最近好忙，抽空摸一题&lt;/p&gt;
&lt;h3 id=&quot;题目：&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="简单" scheme="https://coolling.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>OSDI18-Gandiva</title>
    <link href="https://coolling.github.io/2024/04/03/OSDI18-Gandiva/"/>
    <id>https://coolling.github.io/2024/04/03/OSDI18-Gandiva/</id>
    <published>2024-04-03T10:58:59.000Z</published>
    <updated>2024-04-03T11:05:59.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gandiva"><a href="#Gandiva" class="headerlink" title="Gandiva"></a>Gandiva</h1><p>OSDI18</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>a.深度学习作业是计算密集型的，严重依赖GPU；</p><p>b.依赖集群调度程序来确保GPU的高效利用，但是目前使用的是传统专为处理大数据作业使用的集群调度程序；</p><p>c.DLT作业被简单地视为另一个大数据作业，它在作业启动时分配一组 GPU，并在完成之前保留对其 GPU 的独占访问权</p><blockquote><p>高延迟（队头阻塞）和低利用率（作业无法充分利用其分配的 GPU）</p></blockquote><h2 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h2><p>Gandiva，一种新的调度框架，通过根据深度学习工作负载的独特特征定制的调度框架，可以显着提高集群效率</p><h2 id="深度学习特征"><a href="#深度学习特征" class="headerlink" title="深度学习特征"></a>深度学习特征</h2><ul><li>反馈驱动的探索</li></ul><p>用户通常会尝试一个作业的多种配置进行试错（multi-job），使用早期反馈来进行决策【称为超参数搜索，可以是手动的，也可以是自动的】</p><blockquote><p>超参数搜索通常会探索数百种超参数配置，每一轮根据早期反馈（几百个迭代）将低效的配置作业杀掉</p></blockquote><p>而确定了超参数的作业会运行数小时至数天。</p><blockquote><p><strong>这会导致队头阻塞，需要早期反馈的多项作业在队列中等待</strong></p></blockquote><ul><li>DLT作业是异构的，针对的领域不同</li></ul><p>在内存使用、GPU利用率、带宽需求、GPU之间的关联、其他作业的干扰等方面不同</p><p><img src="/../images/Gandiva/gandiva-1.png" alt="关联"></p><blockquote><p><strong>将作业视为黑匣子的传统调度程序将实现次优的集群效率</strong></p></blockquote><ul><li>作业内的可预测性</li></ul><p>一个作业由数百万个相似小批次迭代组成</p><p><img src="/../images/Gandiva/gandiva-2.png" alt="相似"></p><p>【例如，DLT 作业的 GPU RAM 使用遵循与小批次边界对齐的循环模式。前向传递期间内存增加，后向传递期间内存减少。使用的最大和最小 GPU 内存分别为 23GB 和 0.3GB，即 77 倍。该比率随小批次大小而变化】</p><blockquote><p><strong>Gandiva 利用这种循环可预测性来实现高效的应用程序感知时间切片：</strong>DLT 作业可以自动拆分为小批次迭代，并且这些 60 秒以上迭代的集合作为微任务，形成调度间隔；在内存占用最少时执行挂起，显著减小从 GPU 复制并保存在 CPU 中的内存量</p><p><strong>Gandiva使用小批次进度来不断反思其决策，以提高集群效率：</strong>将通信密集型作业动态迁移到更关联的 GPU；动态增加&#x2F;缩小作业的并行度</p></blockquote><h2 id="Gandiva设计"><a href="#Gandiva设计" class="headerlink" title="Gandiva设计"></a><strong>Gandiva设计</strong></h2><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>a.Gandiva 允许传入作业与现有作业分时 GPU，而不是等待当前作业结束。</p><p>使用专为 DLT 作业定制的自定义<strong>挂起-恢复suspend-resume</strong>机制以及<strong>选择性打包</strong>来实现的</p><p>b.Gandiva 支持 DLT 作业从一组 GPU 高效<strong>迁移</strong>到另一组 GPU</p><p>进行碎片整理</p><p>c.Gandiva 支持 <strong>GPU 增长-收缩</strong>机制，以便可以使用空闲 GPU</p><p>d.Gandiva 通过不断<strong>分析</strong> DLT 作业的资源使用情况并评估其性能来<strong>反思</strong></p><ul><li><strong>机制1:suspend-resume</strong></li></ul><blockquote><p>利用现代操作系统支持 CPU 进程时间切片的高效挂起&#x2F;恢复，并添加了对 GPU 时间切片的自定义支持</p></blockquote><p>DLT 作业对 GPU 内存的使用具有循环模式，最小和最大内存使用量之间的差异高达 77 倍。【在 GPU 内存使用率最低时挂起作业】</p><p>（<strong>suspend-resume小模型花费小于100ms，大模型大概1s，给定 1 分钟的时间切片间隔，这相当于 2% 或更少的开销</strong>）</p><ul><li><strong>机制2:packing</strong></li></ul><p>在 GPU 上同时运行多个 DLT 作业。仅当打包的作业不超出 GPU 资源（核心、内存）并且不会相互产生不利影响时，GPU 中的打包才是高效的。</p><ul><li><strong>机制3:迁移</strong></li></ul><p>更改分配给 DLT 作业的 GPU 集</p><blockquote><p>将时间切片作业移动到集群中空出的GPU；将相互干扰的作业迁移出去；对集群进行碎片整理，以便传入的作业获得具有良好局部性的 GPU。</p></blockquote><p><strong>评估两种方法：</strong></p><p>1.<strong>通用进程迁移机制，如CRIU</strong>（<span style="color: rgb(77, 77, 77)"><span style="background-color: rgb(255, 255, 255)">可以冻结一个正在运行的程序，并且checkpoint它到一系列的文件，然后你就可以使用这些文件在任何主机重新恢复这个程序到被冻结的那个点(白话就是实现对已运行程序的备份和恢复)</span></span>）</p><p>由于 CRIU 本身不支持使用 GPU 设备的进程迁移，因此首先checkpoint GPU 对象并在调用 CRIU 之前从进程中删除所有 GPU 状态。</p><p>checkpoint大小在GB级别，单GPU迁移开销为8-10s</p><p>2.<strong>在迁移之前预热目的地并且仅迁移必要的训练状态</strong></p><p>迁移开销只需1-2s</p><blockquote><p>无论哪种方法，服务器间迁移的开销是值得的</p></blockquote><ul><li><strong>机制4:增长-收缩GPU</strong></li></ul><p>根据负载动态增加&#x2F;减少作业可用的GPU数量</p><p>仅将此机制应用于那些明确声明其足以利用这些增长GPU的 DLT 作业</p><ul><li><strong>机制5:分析</strong></li></ul><p>Gandiva 监控资源使用情况，例如 CPU 和 GPU 利用率、CPU&#x2F;GPU 内存等；<strong>内省 DLT 作业，以估计其进度</strong></p><p>Gandiva 估计 DLT 作业的小批次时间，会在调度决策之前和之后比较 DLT 的小批次时间，以确定其有效性（比如说发现打包策略低效，就不打包他们，恢复到suspend-resume机制）</p><h3 id="调度策略：怎么使用上面的机制？"><a href="#调度策略：怎么使用上面的机制？" class="headerlink" title="调度策略：怎么使用上面的机制？"></a>调度策略：怎么使用上面的机制？</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h4><p>作业被封装在容器中：包括所需 GPU 的数量及其优先级以及一个指示作业是否能够增长或收缩的标志</p><p>height：M&#x2F;N，M 是分配的 GPU 数量，N 是 GPU 总数。当height超过1，启动suspend-resume机制。集群的height定义为其所有服务器的最大height。</p><p>服务器的关联affinity：最初为零，如果将需要两个 GPU 的作业分配给服务器，则该服务器的关联affinity将更改为 2。调度程序使用此参数将具有相似 GPU 要求的作业分配给同一服务器。</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong>目标</strong></h4><p>主要设计目标是为作业提供早期反馈。第二个设计目标是集群效率。</p><h4 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a><strong>两种模式</strong></h4><p>可以同时在两种模式下运行</p><p><strong>1.reactive反应模式</strong>：指的是调度程序对作业到达、离开、机器故障等事件做出反应</p><p><strong>a.当新作业到达时</strong>，调度程序会为该作业分配服务器&#x2F;GPU。</p><p>Gandiva 尝试找到与新作业具有相同affinity的节点，且其height小于 1，则分配该节点。否则，Gandiva 尝试查找并分配affinity为0节点。如果没有这样的空闲服务器可用，Gandiva忽略关联性。</p><p>如果以上都没有，说明没有空闲GPU可用，则使用suspend-resume机制，如果存在具有相同affinity的节点，则使用suspend-resume，否则作业将排队</p><p><strong>b.Gandiva中，检查集群的height是否可以降低</strong></p><p>将挂起的作业迁移到新腾出的 GPU 上。</p><p><strong>2..introspective内省模式</strong>：一个连续的过程，其中调度程序旨在提高集群利用率</p><p><strong>a.packing打包</strong>，在过载时才考虑打包</p><p>如果打包作业的​​内存需求组合高于 GPU 内存，则 CPU 内存“分页”的开销会非常高 ，从而导致打包无效。</p><p>当两个或多个作业的内存需求小于 GPU 内存时，打包仍然可能不会比suspend-resume更有效。比如说作业之间的干扰。</p><p><strong>如何确定是否打包？</strong></p><blockquote><p>当作业到达时，suspend-resume模式运行，并收集分析信息（GPU 利用率、内存和作业进度）。</p><p>调度程序维护按 GPU 利用率排序的作业列表。</p><p>选择GPU利用率最低的作业将它打包在利用率最低的GPU（仅当打包作业的​​组合内存利用率不超过 GPU 的总内存时）。</p><p>当打包作业的​​总吞吐量大于时间切片模式时，打包被视为成功。如果不成功就取消打包</p></blockquote><p><strong>b.迁移</strong></p><p>使用迁移改善作业局部性</p><p><img src="/../images/Gandiva/gandiva-3.png" alt="迁移"></p><p>（三分钟后，后台训练作业 DeepSpeech 完成并释放其 8 个 GPU。）</p><p>整理资源碎片：在所有非空闲服务器中选择具有最多空闲 GPU 的服务器。将该服务器上运行的作业转移到其他服务器上。</p><p>重复此操作，直到每个非空闲服务器上的可用 GPU 数量小于阈值（在作者实验中为 4 个中的 3 个），或者没有作业将从迁移中受益。</p><p><strong>c.增长-收缩grow-shrink</strong></p><p>仅当集群未充分利用并且 DLT 作业明确将自己标识为适合增长-收缩时，才会触发增长-收缩。只会增加作业以使用单个服务器中可用的最大 GPU 数量。</p><p><strong>d.时间切片</strong></p><p>支持每个服务器中的循环调度，以公平地共享 GPU 时间</p><p>当作业具有多个优先级时，较高优先级的作业将永远不会被暂停以容纳较低优先级的作业。</p><p>如果服务器已被较高优先级作业充分利用，则较低优先级作业将迁移到另一台服务器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Gandiva&quot;&gt;&lt;a href=&quot;#Gandiva&quot; class=&quot;headerlink&quot; title=&quot;Gandiva&quot;&gt;&lt;/a&gt;Gandiva&lt;/h1&gt;&lt;p&gt;OSDI18&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;header</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://coolling.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="集群调度" scheme="https://coolling.github.io/tags/%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/"/>
    
    <category term="OSDI" scheme="https://coolling.github.io/tags/OSDI/"/>
    
    <category term="18年" scheme="https://coolling.github.io/tags/18%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>331. 验证二叉树的前序序列化</title>
    <link href="https://coolling.github.io/2024/04/01/331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://coolling.github.io/2024/04/01/331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-04-01T09:21:50.000Z</published>
    <updated>2024-04-01T09:50:40.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="331-验证二叉树的前序序列化"><a href="#331-验证二叉树的前序序列化" class="headerlink" title="331. 验证二叉树的前序序列化"></a>331. 验证二叉树的前序序列化</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>序列化二叉树的一种方法是使用 <strong>前序遍历</strong> 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p><strong>保证</strong> 每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p><p>你可以认为输入格式总是有效的</p><ul><li>例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</li></ul><p><strong>注意：</strong>不允许重建树。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = &quot;9,#,#,1&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 104</code></li><li><code>preorder</code> 由以逗号 <code>“，”</code> 分隔的 <code>[0,100]</code> 范围内的整数和 <code>“#”</code> 组成</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题我是看了题解的思路才会的ww菜菜</p><p>a.首先，这道题是给出一个前序序列进行验证是否是正确的前序序列。</p><p>b.如何验证呢？模拟前序序列重建的过程。首先要明白前序遍历是一个dfs的过程，所以这里我们要用栈来进行处理。每处理一层，就将该层剩余的槽位数推入栈中。一开始我们先往栈中推入一个1，代表第一层有一个为根节点准备的空槽位，之后开始遍历这个前序序列。如果这个栈顶的数字为0，则一直pop，直到找到一个栈顶不为0的数，这个过程也是模拟的前序遍历dfs时回退的过程。如果当前遍历的是‘#’，则栈顶数字减一，代表这一层的空槽位减一；如果不为‘#’，则栈顶数字减一，并且再往栈中推入一个2，因为如果当前读到的不是个空节点，那么他肯定还有下一层，根据dfs的特性，我们要先处理这个更深一层的节点，所以把他推入栈中。</p><p>c.如果题目是验证后序遍历呢？那么和前序遍历是一样的，只是从这个序列的后面开始遍历这个字符串</p><p>d.如果题目是验证中序遍历呢？发现中序遍历的序列结果全是“#x#x#x#x#”这种形式的，x代表数字。思考了一下为什么会这样。当我们从左到右处理这个中序序列时，除了读入的第一个字符，之后的字符，要么是来当目前子树的父节点的，要么是要加入一个右节点的，而根节点必然是个x，而右节点必然是个#，因为如果我们挂上了一个x在某个右节点，此时这个x节点必然有一个悬空的左节点，但在中序序列的遍历中，我们不会为他挂上左节点，导致这棵树不能成为真正的树。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSerialization</span><span class="params">(string preorder1)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; preorder;</span><br><span class="line">        <span class="type">int</span> n=preorder1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> last=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder1[i]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                preorder.<span class="built_in">push_back</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                last=<span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(preorder1[i]==<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(last==<span class="literal">true</span>)&#123;</span><br><span class="line">                    preorder.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                last=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last==<span class="literal">true</span>)&#123;</span><br><span class="line">            preorder.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        n=preorder.<span class="built_in">size</span>();</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">        re.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!re.<span class="built_in">empty</span>()&amp;&amp;t&lt;n)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(re.<span class="built_in">top</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">                re.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(re.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(re.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> q=re.<span class="built_in">top</span>();</span><br><span class="line">            re.<span class="built_in">pop</span>();</span><br><span class="line">            re.<span class="built_in">push</span>(q<span class="number">-1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(preorder[t]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                re.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            t++;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t&lt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(re.<span class="built_in">top</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;331-验证二叉树的前序序列化&quot;&gt;&lt;a href=&quot;#331-验证二叉树的前序序列化&quot; class=&quot;headerlink&quot; title=&quot;331. 验证二叉树的前序序列化&quot;&gt;&lt;/a&gt;331. 验证二叉树的前序序列化&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://coolling.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="栈" scheme="https://coolling.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>SC23-EasyScale</title>
    <link href="https://coolling.github.io/2024/03/31/SC23-EasyScale/"/>
    <id>https://coolling.github.io/2024/03/31/SC23-EasyScale/</id>
    <published>2024-03-30T19:26:07.000Z</published>
    <updated>2024-03-30T19:43:16.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EasyScale-Elastic-Training-with-Consistent-Accuracy-and-Improved-Utilization-on-GPUs"><a href="#EasyScale-Elastic-Training-with-Consistent-Accuracy-and-Improved-Utilization-on-GPUs" class="headerlink" title="EasyScale:Elastic Training with Consistent Accuracy and Improved Utilization on GPUs"></a>EasyScale:Elastic Training with Consistent Accuracy and Improved Utilization on GPUs</h1><p>SC2023</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>a.固定数量的GPU使得资源分配排队时间长，集群利用率低</p><p>b.目前的弹性扩展方案根据可用资源改变超参数和训练过程，从而引入了<strong>不确定性，导致影响准确性</strong>。</p><p><img src="/../images/EasyScale/EasyScale-1.png" alt="目前的弹性扩展方案"></p><blockquote><p>a.使用 PyTorch DDP 时，可以清楚地识别训练过程中超参数 gamma 如何影响训练损失的趋势</p><p>b**.当使用不同数量的 GPU 进行训练时，Pollux 的损失曲线存在许多意想不到的振荡，因此无法为 DL 开发人员揭示明显的趋势，这使得超参数调整的现有知识失效**</p><p><strong>弹性训练的不确定性会导致模型精度不一致并使超参数调整变得复杂</strong></p><p>根本原因在于，现有的弹性训练框架缺乏将资源分配与模型训练过程解耦的能力!</p></blockquote><h2 id="EasyScale"><a href="#EasyScale" class="headerlink" title="EasyScale"></a>EasyScale</h2><p><strong>针对数据并行</strong></p><p><strong>目标：消除DL训练阶段的不确定性，保证弹性训练的准确性与固定DoP训练一致。</strong></p><p><strong>基本思想：将分布式模型训练过程与硬件资源分配解耦。</strong></p><p>关键贡献：</p><ul><li>利用 EST 抽象来保持与 PyTorch DDP 一致的训练行为，并在资源弹性下实现高效的上下文切换</li><li>研究了现有弹性训练框架中模型训练的非确定性行为，并确定了分散在整个 DLT 软件堆栈中的影响模型训练 <strong>按位准确性</strong>的因素。</li><li>提出EasyScale调度器，包括作业内和作业间调度器，以提高整个集群异构GPU资源的利用率。</li></ul><h2 id="EasyScale设计"><a href="#EasyScale设计" class="headerlink" title="EasyScale设计"></a>EasyScale设计</h2><p>由于弹性 GPU 分配时训练过程的行为发生了变化，以前的弹性训练框架无法保持一致的模型精度。</p><blockquote><p>理想情况下，与固定数量 GPU 上的非弹性 DDP 训练相比，弹性训练应该生成<strong>按位相同</strong>的模型参数。</p></blockquote><h3 id="理想情况下"><a href="#理想情况下" class="headerlink" title="理想情况下"></a>理想情况下</h3><p><strong>4GPU-&gt;2GPU</strong></p><p>我们希望四个训练工作线程在两个 GPU 上并行执行</p><p><img src="/../images/EasyScale/EasyScale-2.png" alt="理想情况"></p><p><strong>问题</strong></p><p>内存消耗问题：</p><p>a.在 GPU 上复用多个训练线程，前向传递中的并发内存使用量会增加，容易导致内存不足 (OOM)</p><p>b.CUDA上下文（包括训练框架和CUDA本身）的聚合内存使用量也相当可观。</p><p>例如，16GB V100 GPU 上的 16 个工作线程需要 12GB GPU 内存用于 CUDA 上下文（每个上下文大约 750MB）。</p><blockquote><p>实现准确性一致的弹性训练的<strong>关键挑战</strong>是保留训练行为（例如工作线程数量）以及有效共享 GPU 资源</p></blockquote><h3 id="EasyScaleThread"><a href="#EasyScaleThread" class="headerlink" title="EasyScaleThread"></a>EasyScaleThread</h3><blockquote><p>将训练过程与底层资源分配分开，并且可以通过上下文切换灵活地实现资源共享。</p><p>进一步将 EST 的状态分为有状态上下文和无状态部分，最小化需要保存的上下文大小并优化上下文切换开销</p></blockquote><p><img src="/../images/EasyScale/EasyScale-3.png" alt="EasyScaleThread 流程"></p><p>流程：</p><p>1.每个 EasyScale Worker 都在一个 GPU 上启动</p><p>2.原始 DDP 训练worker的执行被视为 EST 的执行，并且任何 EST（即线程）都可以在训练期间动态分配给 EasyScale worker（即进程）。每个 EasyScale Worker 维护一个 CUDA 上下文以在 EST 之间共享，因此不会消耗多次 GPU 内存。</p><p>3.输入数据被分割到所有 EST 中，EST 以时间分片的方式轮流执行</p><p>4.EasyScale 通过用户注释来挂钩hook模型训练的关键步骤，例如数据加载、模型后向和模型更新。用户定义的模型训练语义，包括模型结构、数据增强、批量大小等保持不变。</p><p>5.当所有 EST 完成局部步骤的执行并且所有产生的梯度被聚合以更新模型参数后，全局步骤完成</p><p>6. EST 在<strong>小批量边界</strong>进行上下文切换。需要保存 EST 的训练状态并将其从 GPU 交换到 CPU，避免过度占用GPU内存</p><blockquote><p>实现轻量级上下文切换的<strong>关键是减少要保存的状态</strong></p><p><strong>EST 的 GPU 内存中驻留的工作集包括时间张量和激活、模型参数和优化状态以及梯度，对每个类别进行不同的处理，以有效减少交换到CPU端的工作集</strong></p><p>a.在前向传递中创建时间张量和激活，并在梯度生成后在后向传递中销毁—&gt;会在小批量结束时自动释放，<strong>不需要交换到 CPU</strong></p><p>b.对于模型参数和优化器状态，​​每个 EasyScale Worker 在训练期间维护一个副本，并且仅在全局步骤结束时更新—-&gt;它们对于所有 EST 都保持相同，直到所有 EST 完成为止，因此它们可以在 EST 之间重用，<strong>无需交换到 CPU</strong></p><p>c.梯度是根据 EST 之间的不同输入数据计算的，并且不能共享或重用—&gt;<strong>上下文切换时只需将梯度交换到CPU</strong></p><p><strong>如何减少梯度同步开销？</strong></p><p>将梯度交换与当前 EST 的后向计算和要切换的下一个 EST 的前向计算重叠。</p></blockquote><p>7.<strong>当训练作业的可用资源（例如 GPU 数量）发生变化（也称为资源弹性）时，EasyScale 会采用按需检查点来保留必要的状态</strong></p><p>检查点包含：所有 EST 的上下文、额外状态（包括训练进度和用于实现准确性一致性的其他状态）和参数（例如模型、优化器和学习率调度器）。</p><p>8.在重新配置的资源上继续进行模型训练后，EasyScale 会让每个工作进程加载额外状态和参数的副本，以及重新分配的 EST 的相应上下文，以便所有 EST 都可以从上次保存的状态恢复。</p><h3 id="消除不确定性"><a href="#消除不确定性" class="headerlink" title="消除不确定性"></a>消除不确定性</h3><blockquote><p>确定整个训练软件堆栈中非确定性的来源，并提出我们消除非确定性的方法</p></blockquote><p><strong>来源</strong></p><p><strong>1.隐式框架状态</strong>:一些算子隐式依赖于其前一层输出之外的附加状态</p><p>Dropout 运算符取决于随机数生成器 (RNG) 状态，而 BatchNorm 运算符则跟踪其运行状态。此外，数据加载器和数据增强还依赖于来自Python、NumPy、PyTorch等的RNG状态。</p><p><strong>2.通信机制</strong>:使用all-reduce进行梯度同步</p><p>a.梯度被收集到梯度桶中:梯度到桶的映射首先遵循计算图的静态逆拓扑顺序,然后根据导出梯度张量的顺序在第一个小批量结束时重建。</p><p>b.当资源增加&#x2F;缩减时，worker将重新启动并重建通信信道，这将改变映射，最终破坏了梯度聚合顺序</p><p><img src="/../images/EasyScale/EasyScale-4.png" alt="梯度桶"></p><p><strong>3.Operator实现</strong>：现有的训练框架在训练过程中可能会为同一个算子选择不同的实现方式，这可能会导致训练精度存在细微的差异。</p><p>选择不同的算子实现有两个原因：</p><p>a.框架、编译器或供应商库采用的基于分析的优化可以在GPU上应用各种内核实现，以根据跨小批量的分析结果优化算子性能。</p><p>b.内核实现可能是特定于硬件的，例如为特定数量的SM单元和低位组件设计的实现，这使得它不适合所有类型的GPU。</p><p><strong>解决方案</strong></p><p><strong>EasyScale 为弹性训练定义了不同级别的确定性，并应用解决方案来保证每个级别的准确性一致。</strong></p><p>1.D0静态确定性：使用固定数量的 GPU 进行多次训练应始终获得相同的模型精度。</p><p>需要一致的框架状态和算子实现</p><blockquote><p>在训练开始时固定 RNG （随机数生成器）的随机种子，并在检查点中记录 RNG 状态。</p><p>至于算子实现，我们禁用基于分析的优化并选择确定性内核实现</p></blockquote><p>2.D1弹性确定性：使用不同数量的 GPU 进行多次训练应始终获得相同的模型精度</p><p>在D0的要求上加上对通信机制的要求。</p><blockquote><p>为每个 EST 分配一个恒定的虚拟通信rank（固定了梯度到桶的映射），并在检查点中存储构成梯度桶的索引。</p></blockquote><p>3.D2异构确定性：使用不同类型的 GPU 进行多次训练应该始终会产生相同的模型精度</p><blockquote><p>选择可以在任何类型的 GPU 上运行的特定数量的 SM 和线程来修改算子实现</p><p>确定库调用中的算法标识符 (algo_id)，确定性地选择相同的运算符实现</p><p>(不会重写运算符，它仅选择确定性运算符实现或为现有运算符指定允许的 SM&#x2F;线程。)</p></blockquote><p>D0和D1开销可以忽略不计。D2 可能会导致某些类型的运算符（例如卷积）产生明显的开销，因为它们无法在 GPU 上利用供应商优化的内核</p><blockquote><p>EasyScale通过扫描 PyTorch nn.Module 来自动分析 DL 模型，以确定它是否依赖于特定于硬件的内核优化。如果没有，则启用 D2，并且弹性训练可以使用异构 GPU。否则，EasyScale 将其使用限制为同构 GPU。</p></blockquote><h3 id="EasyScale-调度程序"><a href="#EasyScale-调度程序" class="headerlink" title="EasyScale 调度程序"></a>EasyScale 调度程序</h3><blockquote><p>提出EasyScale 调度程序来更好地利用同构&#x2F;异构 GPU 来提高集群利用率</p></blockquote><p><img src="/../images/EasyScale/EasyScale-5.png" alt="EasyScale 调度程序"></p><p>inter-job作业间调度程序负责在作业之间分配资源。</p><p>intra-job作业内调度程序用于协调 EST 和当前分配的 GPU。</p><p><strong>总体流程</strong></p><p>1.调度决策从作业间调度程序分派到作业内调度程序。</p><p>2.作业内调度程序根据调度决策重新配置占用的 GPU 资源，查询数据库以获得最佳计划，从而将 EST 重新进行调度。</p><p>3.相反，调度决策来自作业内调度器提交的资源建议Resource proposals，并由作业间调度器批准。</p><p>每个作业内调度程序都利用独立的配套模块来维护计划数据库，从而根据估计的吞吐量提升选择top-K计划作为提交给作业间调度程序的资源建议。</p><p><strong>作业内调度程序</strong></p><p>它的主要职责是在配套模块和计划数据库的帮助下生成 EST 到 GPU 的映射配置。</p><p>职责：</p><p>role1：在当前可用的GPU资源下，它查询数据库并应用估计吞吐量最高的top-1配置。</p><p>role2：假设允许作业扩展以获得更高的训练吞吐量，它会查询数据库以探索新的配置，计算增量 GPU 数量和估计的加速比，然后形成提交给作业间调度程序的资源建议</p><p>role3：一旦收到任何调度计划，它就会相应地缩放 GPU 资源。将 EST 重新调度到当前 GPU（role1），并稍后生成资源建议（role2）。此外，如果观察到增加资源后的速度减慢，它会回退到使用以前的资源并释放新分配的资源</p><p><strong>Companion module配套模块</strong></p><p>配套模块维护计划数据库。</p><p>1.计划数据库的每个计划包括 GPU 资源数量、EST 到 GPU 映射配置以及估计吞吐量。</p><p>2.当作业第一次运行时，配套模块使用历史数据初始化数据库，并在监测到估计吞吐量与报告吞吐量之间的显着偏差后主动更新数据库</p><p>配套模块旨在生成分配适当 EST 的计划，从而实现不同 GPU 之间的负载平衡</p><p>为了估计 EST 到 GPU 映射配置的吞吐量，它使用分析性能模型：考虑分配的EST无法充分利用GPU的计算能力；EST 分配过度；每种GPU的最大过载；如果一种 GPU 类型承担过多的 EST，它就会成为瓶颈，而减慢其他 GPU 的速度，这是一种浪费</p><p><strong>作业间集群调度器</strong></p><p>1.通过考虑可用资源和提案优先级来评估提交的提案</p><p>2.它采用启发式，倾向于接受每个 GPU 加速比更高的建议。如果多个提案提供相同的加速，它会优先考虑具有更多 GPU 的提案。</p><p>3.通过将波动的空闲资源同步到可用资源表中，它支持 EasyScale 作业与其他非弹性作业共置，从而充分利用临时可用的闲置资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;EasyScale-Elastic-Training-with-Consistent-Accuracy-and-Improved-Utilization-on-GPUs&quot;&gt;&lt;a href=&quot;#EasyScale-Elastic-Training-with-Cons</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://coolling.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="23年" scheme="https://coolling.github.io/tags/23%E5%B9%B4/"/>
    
    <category term="弹性训练" scheme="https://coolling.github.io/tags/%E5%BC%B9%E6%80%A7%E8%AE%AD%E7%BB%83/"/>
    
    <category term="SC" scheme="https://coolling.github.io/tags/SC/"/>
    
    <category term="数据并行" scheme="https://coolling.github.io/tags/%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>TPDS21-EDL</title>
    <link href="https://coolling.github.io/2024/03/28/TPDS21-EDL/"/>
    <id>https://coolling.github.io/2024/03/28/TPDS21-EDL/</id>
    <published>2024-03-27T16:24:39.000Z</published>
    <updated>2024-03-28T11:14:35.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elastic-Deep-Learning-in-Multi-Tenant-GPU-Clusters"><a href="#Elastic-Deep-Learning-in-Multi-Tenant-GPU-Clusters" class="headerlink" title="Elastic Deep Learning in Multi-Tenant GPU Clusters"></a>Elastic Deep Learning in Multi-Tenant GPU Clusters</h1><p>2021 TPDS</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>弹性：调整DNN作业并行度</p><p>1.负载均衡问题：GPU集群有时资源空闲有时紧张</p><p>2.基于优先级的调度：减少第优先级作业的规模</p><p>3.集群管理：减缓落后者、性能分析、worker迁移</p><h2 id="目前的解决方法"><a href="#目前的解决方法" class="headerlink" title="目前的解决方法"></a>目前的解决方法</h2><p>Stop-Resume：停下来—&gt;做检查点—-&gt;以想要的并行度启动</p><blockquote><p>需要停止 30 秒以上。耗时！</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><strong>EDL：集群调度器和DL系统之间的轻量级协调层</strong></p><p>1.将单机执行委托给底层 DL 系统</p><p>2.DL系统只需要从 EDL 中检索训练数据块的元数据，并在完成一个mini-batch后通知 EDL。</p><p>3.在 EDL 中，每个作业都由一组worker进程执行，每个进程都与一个 EDL 守护进程关联</p><p>4.每个进程在一个GPU上，计算minibatch中的某些样本梯度</p><p>5.每个作业都由一个领导者进程管理，并且 EDL 使用基于分布式事务的机制来快速选举领导者</p><p>6.使用stop-free扩展，允许现有worker继续训练，同时新添加的worker准备执行。</p><p>7.使用graceful exit在一个minibatch训练结束时删除worker，开销可以忽略不计。</p><p><strong>设计目标：</strong></p><blockquote><p>1.弹性</p><p>2.高效</p><p>3.一致性</p></blockquote><p><strong>优势：</strong></p><blockquote><p>1.EDL可以作为不同DL系统的简单插件并保持良好的可用性，用户只需要在代码中添加几行</p><p>2.并且EDL向用户隐藏所有细节</p><p>3.EDL相比Stop-Resume显著减少开销</p><p>4.确保任何worker随时加入&#x2F;离开工作时的正确性和效率</p></blockquote><p><strong>劣势：</strong></p><blockquote><p>只针对数据并行</p></blockquote><h2 id="EDL设计"><a href="#EDL设计" class="headerlink" title="EDL设计"></a>EDL设计</h2><p>使用NCCL、TCP通信</p><p><img src="/../images/edl/edl-1.png" alt="edl设计"></p><h2 id="自动作业管理"><a href="#自动作业管理" class="headerlink" title="自动作业管理"></a>自动作业管理</h2><p>leader选举：确保始终有一个leader来管理作业</p><p>选举之后，leader建立一个RPCserver接受连接，其他worker则连接到leader并发送注册消息来加入工作。</p><p>1.在作业执行期间，leader根据每个小批量中的梯度同步请求推断worker的活跃度，因此不需要显式的心跳消息。</p><p>2.当调用scale_out()或scale_in()时，leader与新的或退出的worker进行沟通，为他们加入或离开工作做好准备。</p><p>3.leader还构建了一个新的通信拓扑，用于现有worker的分布式训练。</p><h2 id="高效的并行性调整"><a href="#高效的并行性调整" class="headerlink" title="高效的并行性调整"></a>高效的并行性调整</h2><h3 id="scale-out"><a href="#scale-out" class="headerlink" title="scale out"></a><strong>scale out</strong></h3><p>1.上下文准备：加载动态库、准备训练数据、在GPU内存和主内存上分配空间等（占主导地位，耗时最多）</p><p>2.通信拓扑构建：为了通信，新的worker需要连接到leader进行协调，所有的worker需要形成一个新的环形拓扑来进行模型同步。</p><p>3.模型准备：新的worker需要在加入训练之前获得最新的模型</p><p><img src="/../images/edl/edl-2.png" alt="分析"></p><p><strong>无停止缩放</strong></p><p>当新worker进行执行上下文准备时，不需要停止对现有worker的训练。</p><p>1.每个新worker都会启动两个独立的线程，一个主线程和一个后台线程。</p><p>2.主线程进行执行上下文准备，同时后台线程进行leader发现并向leader发送注册请求。</p><p>3.leader在收到新worker的注册请求后，构建包括新worker的新通信拓扑，并将其广播给所有worker</p><p>【原来的通信拓扑还没有被破坏，因此现有的worker可以继续训练而不受影响。】</p><p>4.当新的worker完成执行上下文准备并接收到新的通信拓扑时，它会向leader发送就绪消息，但在收到来自leader的 OK 消息之前，它会被阻塞。</p><p>5.一旦收到来自所有新worker的就绪消息，leader就会向所有worker广播一条 OK 消息和未来时间戳。</p><p>6.worker在小批次结束时进行检查，并在其下一个本地时间戳达到leader指定的时间戳时切换到新的通信拓扑</p><p>7.选择一名现有worker将其模型广播给新worker</p><p>8.新worker获取最新模型后，scale_out()完成，并以新的并行度继续训练</p><p>现有的worker只需要停下来等待模型广播给新的worker，根据实验，大多数模型可以在1秒内完成</p><p><img src="/../images/edl/edl-4.png" alt="比较"></p><h3 id="scale-in"><a href="#scale-in" class="headerlink" title="scale in"></a>scale in</h3><p>1.leader构建一个新的通信拓扑并将其广播给其余的worker</p><p>2.leader也会向所有worker发送未来时间戳，此时退出的worker应离开，剩余的worker应切换到新的通信拓扑</p><p>3.如果是leader离开，之后会选一个新leader</p><h2 id="动态数据管道"><a href="#动态数据管道" class="headerlink" title="动态数据管道"></a>动态数据管道</h2><p>在弹性情况下如何为worker重新划分数据集</p><p>1.等到当前epoch结束时，重新分配worker之间的分区</p><p>这是不灵活的，因为并行度调整只能在当前epoch结束时进行</p><p>2.可以只重新分配当前epoch中未处理的分区，并在当前epoch结束时进行全局重新分配。</p><p>在为某个缩放指令重新分配时又出现另一个缩放指令又要重新分配，以及隐藏数据重新分配的延迟以及处理分区碎片或不平衡使得设计和实现变得复杂</p><p><strong>EDL使用的：</strong></p><blockquote><p>EDL 以按需方式动态地将数据分区分配给worker</p></blockquote><p><img src="/../images/edl/edl-3.png" alt="数据获取"></p><p>数据集在逻辑上分为d个分区，其中d足够大于worker的数量，同时分区的大小仍然足够大以允许高带宽批量读取数据。</p><p>分区仅在元数据级别进行，记录文件名和偏移量，数据集并没有物理分区。</p><p>leader生成分区索引的随机排列，并将其用于动态数据分配。</p><p>1.当worker需要新分区时，它向leader发送数据读取请求。</p><p>2.leader用下一个未分配分区的元数据回复请求。</p><p>3.worker 向分布式文件系统（例如 HDFS ）发出异步 I&#x2F;O 请求以读取该分区</p><p>4.为了进行进度跟踪，每个worker在其当前分区中记录一个偏移量，该偏移量指示下一个小批次应该开始的位置。worker在每个小批次结束时向leader报告其偏移量，并且该信息附加到梯度同步请求中，开销可以忽略不计。</p><p>4.当新的worker加入工作时，leader只需为他们分配一些未处理的分区。</p><p>5.当worker正常退出时，它会向leader报告当前分区的元数据及其在分区中的偏移量，以便leader可以将剩余的未处理数据分配给其他worker</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Elastic-Deep-Learning-in-Multi-Tenant-GPU-Clusters&quot;&gt;&lt;a href=&quot;#Elastic-Deep-Learning-in-Multi-Tenant-GPU-Clusters&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://coolling.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="弹性训练" scheme="https://coolling.github.io/tags/%E5%BC%B9%E6%80%A7%E8%AE%AD%E7%BB%83/"/>
    
    <category term="数据并行" scheme="https://coolling.github.io/tags/%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C/"/>
    
    <category term="TPDS" scheme="https://coolling.github.io/tags/TPDS/"/>
    
    <category term="21年" scheme="https://coolling.github.io/tags/21%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>518. 零钱兑换 II</title>
    <link href="https://coolling.github.io/2024/03/25/518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II/"/>
    <id>https://coolling.github.io/2024/03/25/518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II/</id>
    <published>2024-03-25T07:59:14.000Z</published>
    <updated>2024-03-25T08:17:34.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a>518. 零钱兑换 II</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出：4</span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 3, coins = [2]</span><br><span class="line">输出：0</span><br><span class="line">解释：只用面额 2 的硬币不能凑成总金额 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 10, coins = [10] </span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这道题也是使用动态规划来求解，但是问题是，他求的是组合数，这时候7&#x3D;5+2和7&#x3D;2+5就是同一种组合，不能把它算作两种。因此我们使用动态规划的时候需要确定coins的顺序。设置了一个数组results [n] [m]，意思是对于金额n，现在从coins中的第m个数开始考虑，有几种组合方法。从而可以把问题分解为results [n] [m]&#x3D;result[n] [m+1]+result[n-s] [m+1]+result[n-2s] [m+1]…. s指的是coins[m]的值。</li><li>答案通过了，但是我发现花费的时间和内存都很高。总结了一下有两个原因：a.我每次都是用递归解决动态规划问题b.我开了二维数组</li><li>官方解答的思想其实是和我一样的，但是解说有点小拗口，他的外层循环遍历coins,内存循环遍历amout，对于从0到第n次外层循环，得出的是只使用第1到第n个coins时的组合数，第n+1次外层循环，就会计算加上第n+1个数之后的组合数。因此它的外层循环是用于以一个固定的顺序来组合coins</li><li>在题解中发现了两种解法的对比，发现很有意思的一个现象，两个外层循环交换，一个是求排列数，一个是求组合数。（代码附在下面了）</li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;results,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(amount&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(results[amount][index]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> results[amount][index];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> c = amount/coins[index];</span><br><span class="line">        <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=c;i++)</span><br><span class="line">            re+=<span class="built_in">getResult</span>(amount-i*coins[index],coins,results,index+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        results[amount][index]=re;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">results</span>(amount+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getResult</span>(amount,coins,results,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>贴上求排列数和求组合数的两种方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求排列数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp)); <span class="comment">//初始化数组为0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123; <span class="comment">//枚举金额</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> coin : coins)&#123; <span class="comment">//枚举硬币</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; coin) <span class="keyword">continue</span>; <span class="comment">// coin不能大于amount</span></span><br><span class="line">                dp[j] += dp[j-coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求组合数，也是本题的官方解答</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp)); <span class="comment">//初始化数组为0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins)&#123; <span class="comment">//枚举硬币</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123; <span class="comment">//枚举金额</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; coin) <span class="keyword">continue</span>; <span class="comment">// coin不能大于amount</span></span><br><span class="line">                dp[j] += dp[j-coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：徐洲更<br>链接：<a href="https://leetcode.cn/problems/coin-change-ii/solutions/143948/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/">https://leetcode.cn/problems/coin-change-ii/solutions/143948/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;518-零钱兑换-II&quot;&gt;&lt;a href=&quot;#518-零钱兑换-II&quot; class=&quot;headerlink&quot; title=&quot;518. 零钱兑换 II&quot;&gt;&lt;/a&gt;518. 零钱兑换 II&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="中等" scheme="https://coolling.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="动态规划" scheme="https://coolling.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>322.零钱兑换</title>
    <link href="https://coolling.github.io/2024/03/24/322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>https://coolling.github.io/2024/03/24/322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</id>
    <published>2024-03-24T06:52:18.000Z</published>
    <updated>2024-03-24T06:57:20.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用动态规划来完成，可以这样来划分子问题，以示例1举例：solution(11)&#x3D;min(solution(10),solution(9),solution(6))+1</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins,vector&lt;<span class="type">int</span>&gt;&amp; counts ,<span class="type">int</span> amount )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (amount&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(counts[amount]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> counts[amount];</span><br><span class="line">        <span class="type">int</span> n=coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> min=<span class="number">99999</span>;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tmp=<span class="built_in">getResult</span>(coins,counts,amount-coins[i]);</span><br><span class="line">            <span class="keyword">if</span>(tmp!=<span class="number">-1</span>&amp;&amp;tmp&lt;min)</span><br><span class="line">                min=tmp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=<span class="number">99999</span>)</span><br><span class="line">            counts[amount]=min+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            counts[amount]=<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> counts[amount];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt;  <span class="title">counts</span><span class="params">(amount+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getResult</span>(coins,counts,amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;322-零钱兑换&quot;&gt;&lt;a href=&quot;#322-零钱兑换&quot; class=&quot;headerlink&quot; title=&quot;322.零钱兑换&quot;&gt;&lt;/a&gt;322.零钱兑换&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="中等" scheme="https://coolling.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="动态规划" scheme="https://coolling.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2549. 统计桌面上的不同数字</title>
    <link href="https://coolling.github.io/2024/03/23/2549-%E7%BB%9F%E8%AE%A1%E6%A1%8C%E9%9D%A2%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C%E6%95%B0%E5%AD%97/"/>
    <id>https://coolling.github.io/2024/03/23/2549-%E7%BB%9F%E8%AE%A1%E6%A1%8C%E9%9D%A2%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C%E6%95%B0%E5%AD%97/</id>
    <published>2024-03-23T06:20:30.000Z</published>
    <updated>2024-03-23T06:26:54.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2549-统计桌面上的不同数字"><a href="#2549-统计桌面上的不同数字" class="headerlink" title="2549. 统计桌面上的不同数字"></a>2549. 统计桌面上的不同数字</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个正整数 <code>n</code> ，开始时，它放在桌面上。在 <code>109</code> 天内，每天都要执行下述步骤：</p><ul><li>对于出现在桌面上的每个数字 <code>x</code> ，找出符合 <code>1 &lt;= i &lt;= n</code> 且满足 <code>x % i == 1</code> 的所有数字 <code>i</code> 。</li><li>然后，将这些数字放在桌面上。</li></ul><p>返回在 <code>109</code> 天之后，出现在桌面上的 <strong>不同</strong> 整数的数目。</p><p><strong>注意：</strong></p><ul><li>一旦数字放在桌面上，则会一直保留直到结束。</li><li><code>%</code> 表示取余运算。例如，<code>14 % 3</code> 等于 <code>2</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：4</span><br><span class="line">解释：最开始，5 在桌面上。 </span><br><span class="line">第二天，2 和 4 也出现在桌面上，因为 5 % 2 == 1 且 5 % 4 == 1 。 </span><br><span class="line">再过一天 3 也出现在桌面上，因为 4 % 3 == 1 。 </span><br><span class="line">在十亿天结束时，桌面上的不同数字有 2 、3 、4 、5 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3 </span><br><span class="line">输出：2</span><br><span class="line">解释： </span><br><span class="line">因为 3 % 2 == 1 ，2 也出现在桌面上。 </span><br><span class="line">在十亿天结束时，桌面上的不同数字只有两个：2 和 3 。 </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这道题是个简单题，一开始想着的是求每个出现在桌子上的数-1之后的因子，因为n最大就100，暴力解决</li><li>后来想想，不对，n一定会生成n-1，n-1之后会生成n-2 …..一直到生成2，这样实际上就是会有n-1个不同的数</li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distinctIntegers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2549-统计桌面上的不同数字&quot;&gt;&lt;a href=&quot;#2549-统计桌面上的不同数字&quot; class=&quot;headerlink&quot; title=&quot;2549. 统计桌面上的不同数字&quot;&gt;&lt;/a&gt;2549. 统计桌面上的不同数字&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="数学" scheme="https://coolling.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="简单" scheme="https://coolling.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>ICCD23-LightCheck</title>
    <link href="https://coolling.github.io/2024/03/21/ICCD23-LightCheck/"/>
    <id>https://coolling.github.io/2024/03/21/ICCD23-LightCheck/</id>
    <published>2024-03-21T12:25:21.000Z</published>
    <updated>2024-03-21T12:31:18.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LightCheck：A-Cost-Efﬁcient-Failure-Tolerant-Scheme-for-Distributed-DNN-Training"><a href="#LightCheck：A-Cost-Efﬁcient-Failure-Tolerant-Scheme-for-Distributed-DNN-Training" class="headerlink" title="LightCheck：A Cost-Efﬁcient Failure-Tolerant Scheme for Distributed DNN Training"></a>LightCheck：A Cost-Efﬁcient Failure-Tolerant Scheme for Distributed DNN Training</h1><p>ICCD23</p><p>为了减少检查点开销，我们通过逐层管道化检查点来利用细粒度异步检查点。</p><p>为了进一步减少检查点延迟，我们利用软件-硬件协同设计方法，通过持久内存 (PM) 管理器将新硬件设备合并到我们的检查点系统中。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>检查点在复制模型状态时需要阻塞训练—&gt;开销高</p><p>CheckFreq—-&gt;未能充分利用分布式DNN训练中计算、通信和检查点之间的并行性<br><img src="/../images/LightCheck/lightcheck-1.png" alt="checkfreq"></p><blockquote><p>整个模型状态一次连续复制</p><p>CheckFreq没有充分探究训练过程中的数据依赖性</p></blockquote><h2 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h2><p>LightCheck：为分布式 DNN 训练提供了低开销的频繁检查点。</p><p>a.LightCheck 以逐层方式将检查点与计算和通信进行管道化，从而减轻检查点对训练性能的影响。</p><p>b.有效地结合了PM的直接访问（DAX）功能和统一虚拟寻址（UVA）技术，将PM映射到GPU虚拟地址空间，从而允许从GPU直接访问PM。</p><p>c.进一步使用 CUDA流和事件通过 GPU 计算重叠 GPU-PM 数据传输。</p><p>d.为了提高 PM 写入吞吐量，LightCheck 将 PM 中张量元数据和张量数据的存储分开，从而使张量数据访问在小量写入时连续，在大量写入时对齐。</p><h2 id="LightCheck"><a href="#LightCheck" class="headerlink" title="LightCheck"></a>LightCheck</h2><p>由两个主要组件组成，包括高效的检查点方案和持久内存PM管理器</p><h3 id="检查点方案"><a href="#检查点方案" class="headerlink" title="检查点方案"></a><strong>检查点方案</strong></h3><blockquote><p>根据分布式训练过程中模型训练和检查点之间的数据依赖关系，异步checkpoint模型状态的最新更新部分</p></blockquote><p><strong>策略选择</strong></p><p>有三种不同的检查点策略，包括LightCheck-G、LightCheck-C和LightCheck-D</p><p>LightCheck-G:复制副本到GPU内存；从GPU内存写入PM【最小的快照时间；高GPU内存消耗】</p><p>LightCheck-C:复制副本到CPU内存；从CPU内存写入PM【干扰CPU中的运行进程】</p><p>LightCheck-D:直接将模型状态从GPU内存逐层传输到PM【PM带宽低；复杂的性能特征】【<strong>仔细地将检查点数据写入PM以充分利用PM带宽！</strong>】</p><p><strong>异步逐层检查点</strong><br><img src="/../images/LightCheck/lightcheck-2.png" alt="lightcheck"></p><p>将检查点与计算和通信进行管道化，以将检查点嵌入到训练数据流中。当某一层的梯度同步和参数更新完成后，该层的检查点就准备开始了。将检查点操作放入 FIFO 队列中，并使用后台线程异步执行它。</p><h3 id="持久内存管理器"><a href="#持久内存管理器" class="headerlink" title="持久内存管理器"></a><strong>持久内存管理器</strong></h3><blockquote><p>通过将PM映射到GPU虚拟内存空间并组织PM中检查点数据的存储位置，实现GPU内存和持久内存之间的有效数据传输。</p></blockquote><p><strong>三种技术</strong></p><p>a.直接内存访问 (DMA) 技术：它利用固定缓冲区作为主机内存和 GPU 内存之间数据传输的暂存区域</p><p>PM 的 DAX 功能：将 PM 直接映射到 CPU 地址空间</p><blockquote><p>可以通过 DMA 数据路径通过 cudaMemcpy API 在 PM 和 GPU 内存之间传输数据</p><p><strong>然而，通过DMA数据路径传输数据仍然需要经过CPU内存中的固定缓冲区，从而阻碍了传输性能。</strong></p></blockquote><p>b.统一内存（UM）技术，它进一步在全局内存地址空间中管理设备和主机内存，并自动在PM和GPU内存之间迁移内存页面。</p><blockquote><p>简化了编程，<strong>但仍然需要隐式页面迁移，这很难扩展统一内存以包含PM。</strong></p></blockquote><p>c.统一虚拟寻址（UVA）技术，它可以使用全局内存地址空间通过 PCIe 进行零拷贝访问</p><p>将PM映射到GPU虚拟地址空间</p><blockquote><p>该技术允许GPU内核在将PM映射到GPU虚拟地址空间后直接访问PM。</p><p><strong>与DMA和UM相比，UVA技术具有高性能并提高了易用性。</strong></p></blockquote><p>因此，我们使用 UVA 技术在 LightCheck 中的 PM 和 GPU 内存之间传输数据。</p><p>内存复制是通过使用后台线程在额外的 CUDA 流上执行的。</p><p>此外，由于训练需要检查检查点过程是否完成，LightCheck 通过 CUDA 事件监控 GPU-PM 内存复制的进度。</p><h3 id="检查点存储管理"><a href="#检查点存储管理" class="headerlink" title="检查点存储管理"></a>检查点存储管理</h3><p>对于检查点，除了张量元数据和一些附加状态（例如当前epoch、当前迭代和训练数据索引）之外，几乎所有数据都是以张量格式构造的</p><p>一般来说，检查点数据以字典的形式组织。在 PM 中复制和维护数据结构以匹配用于加载模型状态的训练框架接口（即load_state_dict()）非常重要。</p><blockquote><p>然而，由于 PM 对小随机写入敏感，因此通过 PCIe 接口的 GPU-PM 访问需要与 128 字节粒度保持一致，以实现更好的 PCIe 带宽利用率。</p><p>未对齐的访问会生成两个单独的 PCIe 请求，导致高 PM 写放大。</p></blockquote><p>LightCheck将检查点数据空间划分为数据映射区域和连续张量区域。</p><p>a.数据映射由PM中张量数据的地址和张量数据的字节数组成。</p><p>PM 中存储的数据映射可供所有 GPU 和 CPU 访问。基于UVA技术，PM中的每个张量都有一个供所有GPU和CPU使用的全局虚拟地址，处理器可以直接将张量写入PM中的相应位置。</p><p>在检查点文件初始化期间，LightCheck 分配 PM 空间并为张量创建数据映射。在PM中分配空间时，LightCheck按照访问顺序连续存储小张量数据，并在连续张量数据区域中以对齐的 PCIe 粒度为大于 128 字节的张量顺序分配内存。</p><blockquote><p>得益于分离的检查点存储管理，LightCheck可以显着缓解PM写入放大，并减少从GPU内存向PM写入检查点所需的PCIe请求数量。</p></blockquote><p>另外，LightCheck 仅为训练模型维护两个检查点数据映射。一旦一个检查点完成，另一个检查点就会被废弃。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LightCheck：A-Cost-Efﬁcient-Failure-Tolerant-Scheme-for-Distributed-DNN-Training&quot;&gt;&lt;a href=&quot;#LightCheck：A-Cost-Efﬁcient-Failure-Tolera</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://coolling.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="故障恢复" scheme="https://coolling.github.io/tags/%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/"/>
    
    <category term="ICCD" scheme="https://coolling.github.io/tags/ICCD/"/>
    
    <category term="23年" scheme="https://coolling.github.io/tags/23%E5%B9%B4/"/>
    
    <category term="检查点" scheme="https://coolling.github.io/tags/%E6%A3%80%E6%9F%A5%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2671.频率跟踪器</title>
    <link href="https://coolling.github.io/2024/03/21/2671-%E9%A2%91%E7%8E%87%E8%B7%9F%E8%B8%AA%E5%99%A8/"/>
    <id>https://coolling.github.io/2024/03/21/2671-%E9%A2%91%E7%8E%87%E8%B7%9F%E8%B8%AA%E5%99%A8/</id>
    <published>2024-03-21T04:47:01.000Z</published>
    <updated>2024-03-21T04:58:50.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1793-好子数组的最大分数"><a href="#1793-好子数组的最大分数" class="headerlink" title="1793. 好子数组的最大分数"></a>1793. 好子数组的最大分数</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。</p><p>实现 <code>FrequencyTracker</code> 类：</p><ul><li><code>FrequencyTracker()</code>：使用一个空数组初始化 <code>FrequencyTracker</code> 对象。</li><li><code>void add(int number)</code>：添加一个 <code>number</code> 到数据结构中。</li><li><code>void deleteOne(int number)</code>：从数据结构中删除一个 <code>number</code> 。数据结构 <strong>可能不包含</strong> <code>number</code> ，在这种情况下不删除任何内容。</li><li><code>bool hasFrequency(int frequency)</code>: 如果数据结构中存在出现 <code>frequency</code> 次的数字，则返回 <code>true</code>，否则返回 <code>false</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;FrequencyTracker&quot;, &quot;add&quot;, &quot;add&quot;, &quot;hasFrequency&quot;]</span><br><span class="line">[[], [3], [3], [2]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">FrequencyTracker frequencyTracker = new FrequencyTracker();</span><br><span class="line">frequencyTracker.add(3); // 数据结构现在包含 [3]</span><br><span class="line">frequencyTracker.add(3); // 数据结构现在包含 [3, 3]</span><br><span class="line">frequencyTracker.hasFrequency(2); // 返回 true ，因为 3 出现 2 次</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;FrequencyTracker&quot;, &quot;add&quot;, &quot;deleteOne&quot;, &quot;hasFrequency&quot;]</span><br><span class="line">[[], [1], [1], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, false]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">FrequencyTracker frequencyTracker = new FrequencyTracker();</span><br><span class="line">frequencyTracker.add(1); // 数据结构现在包含 [1]</span><br><span class="line">frequencyTracker.deleteOne(1); // 数据结构现在为空 []</span><br><span class="line">frequencyTracker.hasFrequency(1); // 返回 false ，因为数据结构为空</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;FrequencyTracker&quot;, &quot;hasFrequency&quot;, &quot;add&quot;, &quot;hasFrequency&quot;]</span><br><span class="line">[[], [2], [3], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, false, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">FrequencyTracker frequencyTracker = new FrequencyTracker();</span><br><span class="line">frequencyTracker.hasFrequency(2); // 返回 false ，因为数据结构为空</span><br><span class="line">frequencyTracker.add(3); // 数据结构现在包含 [3]</span><br><span class="line">frequencyTracker.hasFrequency(1); // 返回 true ，因为 3 出现 1 次</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= number &lt;= 105</code></li><li><code>1 &lt;= frequency &lt;= 105</code></li><li>最多调用 <code>add</code>、<code>deleteOne</code> 和 <code>hasFrequency</code> <strong>共计</strong> <code>2 * 105</code> 次</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目第一眼看是用map，做了一半之后发现是用数组……但其实用数组也是一样的，用两个数组，一个数字映射对应的频率，一个是频率映射对应的数字。</p><p>发现语法好多不会勒，忘了初始化的时候数组中不为0，要自己初始化</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FrequencyTracker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num[<span class="number">100001</span>] ;</span><br><span class="line">    <span class="type">int</span> frequencys[<span class="number">100001</span>] ;</span><br><span class="line">    <span class="built_in">FrequencyTracker</span>() &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100001</span>;i++)&#123;</span><br><span class="line">        num[i]=<span class="number">0</span>;</span><br><span class="line">        frequencys[i]=<span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        frequencys[num[number]]--;</span><br><span class="line">        num[number]++;</span><br><span class="line">        frequencys[num[number]]++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteOne</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[number]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            frequencys[num[number]]--;</span><br><span class="line">            num[number]--;</span><br><span class="line">            frequencys[num[number]]++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasFrequency</span><span class="params">(<span class="type">int</span> frequency)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> frequencys[frequency]&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1793-好子数组的最大分数&quot;&gt;&lt;a href=&quot;#1793-好子数组的最大分数&quot; class=&quot;headerlink&quot; title=&quot;1793. 好子数组的最大分数&quot;&gt;&lt;/a&gt;1793. 好子数组的最大分数&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="中等" scheme="https://coolling.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="哈希" scheme="https://coolling.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>1793. 好子数组的最大分数</title>
    <link href="https://coolling.github.io/2024/03/19/1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/"/>
    <id>https://coolling.github.io/2024/03/19/1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/</id>
    <published>2024-03-19T08:40:32.000Z</published>
    <updated>2024-03-19T09:05:05.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1793-好子数组的最大分数"><a href="#1793-好子数组的最大分数" class="headerlink" title="1793. 好子数组的最大分数"></a>1793. 好子数组的最大分数</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个整数数组 <code>nums</code> <strong>（下标从 0 开始）</strong>和一个整数 <code>k</code> 。</p><p>一个子数组 <code>(i, j)</code> 的 <strong>分数</strong> 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code> 。一个 <strong>好</strong> 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。</p><p>请你返回 <strong>好</strong> 子数组的最大可能 <strong>分数</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,4,3,7,4,5], k = 3</span><br><span class="line">输出：15</span><br><span class="line">解释：最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,5,4,5,4,1,1,1], k = 0</span><br><span class="line">输出：20</span><br><span class="line">解释：最优子数组的左右端点下标是 (0, 4) ，分数为 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 104</code></li><li><code>0 &lt;= k &lt; nums.length</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这种题型还挺经典的，双指针。</p><ol><li><p>因为题目给定了一个k要在范围内，所以很自然地，i和j两个指针可以从k的两边开始遍历。</p></li><li><p>为了最大化<code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code>,i和j分别向两边移动，以增加<code>(j - i + 1)</code>。</p></li><li><p>但是在增加的过程中，如果遇到一些更小的数，反而会减少<code>min(nums[i], nums[i+1], ..., nums[j])</code>。这个时候就要决定怎么扩展，移动<code>i</code>还是移动<code>j</code>？应该移动num[i]和num[j]更大的那一个，这是很显然的，我浅浅证明一下：</p><p>a.当num[i-1]和num[j+1]都大于min的情况下，移动i和移动j都一样</p><p>b.当num[i-1]和num[j+1]都小于min的情况下，假如num[i-1]&lt;num[j+1]，移动哪个都会使min更新，移动向num[j+1]，结果为num[j+1] (j - i + 1)；移动向num[i-1]，结果为num[i-1] (j - i + 1)。显然，移动j得到的结果num[j+1] (j - i + 1)会更大，因为num[i-1]&lt;num[j+1]</p><p>c.当num[i-1]和num[j+1]一个小于min，一个大于min,很显然，移动较大的那个不会使min减小。</p></li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=k;</span><br><span class="line">        <span class="type">int</span> j=k;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum=nums[k];</span><br><span class="line">        <span class="type">int</span> min=nums[k];</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">while</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;j+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">            <span class="comment">//在选择扩展i-1或者j+1时，选择扩展更大的那个</span></span><br><span class="line">            t=nums[j+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&gt;=nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                t=nums[i<span class="number">-1</span>];</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">            <span class="comment">//更新最小值</span></span><br><span class="line">            <span class="keyword">if</span> (min &gt; t)</span><br><span class="line">                min=t;</span><br><span class="line">            <span class="comment">//更新结果</span></span><br><span class="line">            <span class="keyword">if</span>(min*(j-i+<span class="number">1</span>)&gt;sum)</span><br><span class="line">                sum=min*(j-i+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//跳出循环后，检查一下左边是否遍历完</span></span><br><span class="line">        <span class="keyword">while</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            t=nums[i<span class="number">-1</span>];</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; t)</span><br><span class="line">                min=t;</span><br><span class="line">            <span class="keyword">if</span>(min*(j-i+<span class="number">1</span>)&gt;sum)</span><br><span class="line">                sum=min*(j-i+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//跳出循环后，检查一下右边是否遍历完</span></span><br><span class="line">        <span class="keyword">while</span>(j+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">            t=nums[j+<span class="number">1</span>];</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; t)</span><br><span class="line">                min=t;</span><br><span class="line">            <span class="keyword">if</span>(min*(j-i+<span class="number">1</span>)&gt;sum)</span><br><span class="line">                sum=min*(j-i+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>贴上官方解答，其实是一个意思，但是写的好简洁，再学习一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = k - <span class="number">1</span>, right = k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums[k];;) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; nums[left] &gt;= i) &#123;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; n &amp;&amp; nums[right] &gt;= i) &#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right - left - <span class="number">1</span>) * i);</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="number">-1</span> &amp;&amp; right == n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = <span class="built_in">max</span>((left == <span class="number">-1</span> ? <span class="number">-1</span> : nums[left]), (right == n ? <span class="number">-1</span> : nums[right]));</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/maximum-score-of-a-good-subarray/solutions/2688286/hao-zi-shu-zu-de-zui-da-fen-shu-by-leetc-94gx/">https://leetcode.cn/problems/maximum-score-of-a-good-subarray/solutions/2688286/hao-zi-shu-zu-de-zui-da-fen-shu-by-leetc-94gx/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1793-好子数组的最大分数&quot;&gt;&lt;a href=&quot;#1793-好子数组的最大分数&quot; class=&quot;headerlink&quot; title=&quot;1793. 好子数组的最大分数&quot;&gt;&lt;/a&gt;1793. 好子数组的最大分数&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="困难" scheme="https://coolling.github.io/tags/%E5%9B%B0%E9%9A%BE/"/>
    
    <category term="双指针" scheme="https://coolling.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
