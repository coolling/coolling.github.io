<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coolling</title>
  
  
  <link href="https://coolling.github.io/atom.xml" rel="self"/>
  
  <link href="https://coolling.github.io/"/>
  <updated>2024-03-28T11:14:35.860Z</updated>
  <id>https://coolling.github.io/</id>
  
  <author>
    <name>Coolling</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TPDS21-EDL</title>
    <link href="https://coolling.github.io/2024/03/28/TPDS21-EDL/"/>
    <id>https://coolling.github.io/2024/03/28/TPDS21-EDL/</id>
    <published>2024-03-27T16:24:39.000Z</published>
    <updated>2024-03-28T11:14:35.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elastic-Deep-Learning-in-Multi-Tenant-GPU-Clusters"><a href="#Elastic-Deep-Learning-in-Multi-Tenant-GPU-Clusters" class="headerlink" title="Elastic Deep Learning in Multi-Tenant GPU Clusters"></a>Elastic Deep Learning in Multi-Tenant GPU Clusters</h1><p>2021 TPDS</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>弹性：调整DNN作业并行度</p><p>1.负载均衡问题：GPU集群有时资源空闲有时紧张</p><p>2.基于优先级的调度：减少第优先级作业的规模</p><p>3.集群管理：减缓落后者、性能分析、worker迁移</p><h2 id="目前的解决方法"><a href="#目前的解决方法" class="headerlink" title="目前的解决方法"></a>目前的解决方法</h2><p>Stop-Resume：停下来—&gt;做检查点—-&gt;以想要的并行度启动</p><blockquote><p>需要停止 30 秒以上。耗时！</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><strong>EDL：集群调度器和DL系统之间的轻量级协调层</strong></p><p>1.将单机执行委托给底层 DL 系统</p><p>2.DL系统只需要从 EDL 中检索训练数据块的元数据，并在完成一个mini-batch后通知 EDL。</p><p>3.在 EDL 中，每个作业都由一组worker进程执行，每个进程都与一个 EDL 守护进程关联</p><p>4.每个进程在一个GPU上，计算minibatch中的某些样本梯度</p><p>5.每个作业都由一个领导者进程管理，并且 EDL 使用基于分布式事务的机制来快速选举领导者</p><p>6.使用stop-free扩展，允许现有worker继续训练，同时新添加的worker准备执行。</p><p>7.使用graceful exit在一个minibatch训练结束时删除worker，开销可以忽略不计。</p><p><strong>设计目标：</strong></p><blockquote><p>1.弹性</p><p>2.高效</p><p>3.一致性</p></blockquote><p><strong>优势：</strong></p><blockquote><p>1.EDL可以作为不同DL系统的简单插件并保持良好的可用性，用户只需要在代码中添加几行</p><p>2.并且EDL向用户隐藏所有细节</p><p>3.EDL相比Stop-Resume显著减少开销</p><p>4.确保任何worker随时加入&#x2F;离开工作时的正确性和效率</p></blockquote><p><strong>劣势：</strong></p><blockquote><p>只针对数据并行</p></blockquote><h2 id="EDL设计"><a href="#EDL设计" class="headerlink" title="EDL设计"></a>EDL设计</h2><p>使用NCCL、TCP通信</p><p><img src="/../images/edl/edl-1.png" alt="edl设计"></p><h2 id="自动作业管理"><a href="#自动作业管理" class="headerlink" title="自动作业管理"></a>自动作业管理</h2><p>leader选举：确保始终有一个leader来管理作业</p><p>选举之后，leader建立一个RPCserver接受连接，其他worker则连接到leader并发送注册消息来加入工作。</p><p>1.在作业执行期间，leader根据每个小批量中的梯度同步请求推断worker的活跃度，因此不需要显式的心跳消息。</p><p>2.当调用scale_out()或scale_in()时，leader与新的或退出的worker进行沟通，为他们加入或离开工作做好准备。</p><p>3.leader还构建了一个新的通信拓扑，用于现有worker的分布式训练。</p><h2 id="高效的并行性调整"><a href="#高效的并行性调整" class="headerlink" title="高效的并行性调整"></a>高效的并行性调整</h2><h3 id="scale-out"><a href="#scale-out" class="headerlink" title="scale out"></a><strong>scale out</strong></h3><p>1.上下文准备：加载动态库、准备训练数据、在GPU内存和主内存上分配空间等（占主导地位，耗时最多）</p><p>2.通信拓扑构建：为了通信，新的worker需要连接到leader进行协调，所有的worker需要形成一个新的环形拓扑来进行模型同步。</p><p>3.模型准备：新的worker需要在加入训练之前获得最新的模型</p><p><img src="/../images/edl/edl-2.png" alt="分析"></p><p><strong>无停止缩放</strong></p><p>当新worker进行执行上下文准备时，不需要停止对现有worker的训练。</p><p>1.每个新worker都会启动两个独立的线程，一个主线程和一个后台线程。</p><p>2.主线程进行执行上下文准备，同时后台线程进行leader发现并向leader发送注册请求。</p><p>3.leader在收到新worker的注册请求后，构建包括新worker的新通信拓扑，并将其广播给所有worker</p><p>【原来的通信拓扑还没有被破坏，因此现有的worker可以继续训练而不受影响。】</p><p>4.当新的worker完成执行上下文准备并接收到新的通信拓扑时，它会向leader发送就绪消息，但在收到来自leader的 OK 消息之前，它会被阻塞。</p><p>5.一旦收到来自所有新worker的就绪消息，leader就会向所有worker广播一条 OK 消息和未来时间戳。</p><p>6.worker在小批次结束时进行检查，并在其下一个本地时间戳达到leader指定的时间戳时切换到新的通信拓扑</p><p>7.选择一名现有worker将其模型广播给新worker</p><p>8.新worker获取最新模型后，scale_out()完成，并以新的并行度继续训练</p><p>现有的worker只需要停下来等待模型广播给新的worker，根据实验，大多数模型可以在1秒内完成</p><p><img src="/../images/edl/edl-4.png" alt="比较"></p><h3 id="scale-in"><a href="#scale-in" class="headerlink" title="scale in"></a>scale in</h3><p>1.leader构建一个新的通信拓扑并将其广播给其余的worker</p><p>2.leader也会向所有worker发送未来时间戳，此时退出的worker应离开，剩余的worker应切换到新的通信拓扑</p><p>3.如果是leader离开，之后会选一个新leader</p><h2 id="动态数据管道"><a href="#动态数据管道" class="headerlink" title="动态数据管道"></a>动态数据管道</h2><p>在弹性情况下如何为worker重新划分数据集</p><p>1.等到当前epoch结束时，重新分配worker之间的分区</p><p>这是不灵活的，因为并行度调整只能在当前epoch结束时进行</p><p>2.可以只重新分配当前epoch中未处理的分区，并在当前epoch结束时进行全局重新分配。</p><p>在为某个缩放指令重新分配时又出现另一个缩放指令又要重新分配，以及隐藏数据重新分配的延迟以及处理分区碎片或不平衡使得设计和实现变得复杂</p><p><strong>EDL使用的：</strong></p><blockquote><p>EDL 以按需方式动态地将数据分区分配给worker</p></blockquote><p><img src="/../images/edl/edl-3.png" alt="数据获取"></p><p>数据集在逻辑上分为d个分区，其中d足够大于worker的数量，同时分区的大小仍然足够大以允许高带宽批量读取数据。</p><p>分区仅在元数据级别进行，记录文件名和偏移量，数据集并没有物理分区。</p><p>leader生成分区索引的随机排列，并将其用于动态数据分配。</p><p>1.当worker需要新分区时，它向leader发送数据读取请求。</p><p>2.leader用下一个未分配分区的元数据回复请求。</p><p>3.worker 向分布式文件系统（例如 HDFS ）发出异步 I&#x2F;O 请求以读取该分区</p><p>4.为了进行进度跟踪，每个worker在其当前分区中记录一个偏移量，该偏移量指示下一个小批次应该开始的位置。worker在每个小批次结束时向leader报告其偏移量，并且该信息附加到梯度同步请求中，开销可以忽略不计。</p><p>4.当新的worker加入工作时，leader只需为他们分配一些未处理的分区。</p><p>5.当worker正常退出时，它会向leader报告当前分区的元数据及其在分区中的偏移量，以便leader可以将剩余的未处理数据分配给其他worker</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Elastic-Deep-Learning-in-Multi-Tenant-GPU-Clusters&quot;&gt;&lt;a href=&quot;#Elastic-Deep-Learning-in-Multi-Tenant-GPU-Clusters&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://coolling.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="弹性训练" scheme="https://coolling.github.io/tags/%E5%BC%B9%E6%80%A7%E8%AE%AD%E7%BB%83/"/>
    
    <category term="TPDS" scheme="https://coolling.github.io/tags/TPDS/"/>
    
    <category term="21年" scheme="https://coolling.github.io/tags/21%E5%B9%B4/"/>
    
    <category term="数据并行" scheme="https://coolling.github.io/tags/%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>518. 零钱兑换 II</title>
    <link href="https://coolling.github.io/2024/03/25/518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II/"/>
    <id>https://coolling.github.io/2024/03/25/518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II/</id>
    <published>2024-03-25T07:59:14.000Z</published>
    <updated>2024-03-25T08:17:34.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a>518. 零钱兑换 II</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出：4</span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 3, coins = [2]</span><br><span class="line">输出：0</span><br><span class="line">解释：只用面额 2 的硬币不能凑成总金额 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 10, coins = [10] </span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这道题也是使用动态规划来求解，但是问题是，他求的是组合数，这时候7&#x3D;5+2和7&#x3D;2+5就是同一种组合，不能把它算作两种。因此我们使用动态规划的时候需要确定coins的顺序。设置了一个数组results [n] [m]，意思是对于金额n，现在从coins中的第m个数开始考虑，有几种组合方法。从而可以把问题分解为results [n] [m]&#x3D;result[n] [m+1]+result[n-s] [m+1]+result[n-2s] [m+1]…. s指的是coins[m]的值。</li><li>答案通过了，但是我发现花费的时间和内存都很高。总结了一下有两个原因：a.我每次都是用递归解决动态规划问题b.我开了二维数组</li><li>官方解答的思想其实是和我一样的，但是解说有点小拗口，他的外层循环遍历coins,内存循环遍历amout，对于从0到第n次外层循环，得出的是只使用第1到第n个coins时的组合数，第n+1次外层循环，就会计算加上第n+1个数之后的组合数。因此它的外层循环是用于以一个固定的顺序来组合coins</li><li>在题解中发现了两种解法的对比，发现很有意思的一个现象，两个外层循环交换，一个是求排列数，一个是求组合数。（代码附在下面了）</li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;results,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(amount&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(results[amount][index]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> results[amount][index];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> c = amount/coins[index];</span><br><span class="line">        <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=c;i++)</span><br><span class="line">            re+=<span class="built_in">getResult</span>(amount-i*coins[index],coins,results,index+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        results[amount][index]=re;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">results</span>(amount+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getResult</span>(amount,coins,results,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>贴上求排列数和求组合数的两种方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求排列数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp)); <span class="comment">//初始化数组为0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123; <span class="comment">//枚举金额</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> coin : coins)&#123; <span class="comment">//枚举硬币</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; coin) <span class="keyword">continue</span>; <span class="comment">// coin不能大于amount</span></span><br><span class="line">                dp[j] += dp[j-coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求组合数，也是本题的官方解答</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp)); <span class="comment">//初始化数组为0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins)&#123; <span class="comment">//枚举硬币</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123; <span class="comment">//枚举金额</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; coin) <span class="keyword">continue</span>; <span class="comment">// coin不能大于amount</span></span><br><span class="line">                dp[j] += dp[j-coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：徐洲更<br>链接：<a href="https://leetcode.cn/problems/coin-change-ii/solutions/143948/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/">https://leetcode.cn/problems/coin-change-ii/solutions/143948/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;518-零钱兑换-II&quot;&gt;&lt;a href=&quot;#518-零钱兑换-II&quot; class=&quot;headerlink&quot; title=&quot;518. 零钱兑换 II&quot;&gt;&lt;/a&gt;518. 零钱兑换 II&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="中等" scheme="https://coolling.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="动态规划" scheme="https://coolling.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>322.零钱兑换</title>
    <link href="https://coolling.github.io/2024/03/24/322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>https://coolling.github.io/2024/03/24/322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</id>
    <published>2024-03-24T06:52:18.000Z</published>
    <updated>2024-03-24T06:57:20.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用动态规划来完成，可以这样来划分子问题，以示例1举例：solution(11)&#x3D;min(solution(10),solution(9),solution(6))+1</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins,vector&lt;<span class="type">int</span>&gt;&amp; counts ,<span class="type">int</span> amount )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (amount&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(counts[amount]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> counts[amount];</span><br><span class="line">        <span class="type">int</span> n=coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> min=<span class="number">99999</span>;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tmp=<span class="built_in">getResult</span>(coins,counts,amount-coins[i]);</span><br><span class="line">            <span class="keyword">if</span>(tmp!=<span class="number">-1</span>&amp;&amp;tmp&lt;min)</span><br><span class="line">                min=tmp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=<span class="number">99999</span>)</span><br><span class="line">            counts[amount]=min+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            counts[amount]=<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> counts[amount];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt;  <span class="title">counts</span><span class="params">(amount+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getResult</span>(coins,counts,amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;322-零钱兑换&quot;&gt;&lt;a href=&quot;#322-零钱兑换&quot; class=&quot;headerlink&quot; title=&quot;322.零钱兑换&quot;&gt;&lt;/a&gt;322.零钱兑换&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="中等" scheme="https://coolling.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="动态规划" scheme="https://coolling.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2549. 统计桌面上的不同数字</title>
    <link href="https://coolling.github.io/2024/03/23/2549-%E7%BB%9F%E8%AE%A1%E6%A1%8C%E9%9D%A2%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C%E6%95%B0%E5%AD%97/"/>
    <id>https://coolling.github.io/2024/03/23/2549-%E7%BB%9F%E8%AE%A1%E6%A1%8C%E9%9D%A2%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C%E6%95%B0%E5%AD%97/</id>
    <published>2024-03-23T06:20:30.000Z</published>
    <updated>2024-03-23T06:26:54.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2549-统计桌面上的不同数字"><a href="#2549-统计桌面上的不同数字" class="headerlink" title="2549. 统计桌面上的不同数字"></a>2549. 统计桌面上的不同数字</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个正整数 <code>n</code> ，开始时，它放在桌面上。在 <code>109</code> 天内，每天都要执行下述步骤：</p><ul><li>对于出现在桌面上的每个数字 <code>x</code> ，找出符合 <code>1 &lt;= i &lt;= n</code> 且满足 <code>x % i == 1</code> 的所有数字 <code>i</code> 。</li><li>然后，将这些数字放在桌面上。</li></ul><p>返回在 <code>109</code> 天之后，出现在桌面上的 <strong>不同</strong> 整数的数目。</p><p><strong>注意：</strong></p><ul><li>一旦数字放在桌面上，则会一直保留直到结束。</li><li><code>%</code> 表示取余运算。例如，<code>14 % 3</code> 等于 <code>2</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：4</span><br><span class="line">解释：最开始，5 在桌面上。 </span><br><span class="line">第二天，2 和 4 也出现在桌面上，因为 5 % 2 == 1 且 5 % 4 == 1 。 </span><br><span class="line">再过一天 3 也出现在桌面上，因为 4 % 3 == 1 。 </span><br><span class="line">在十亿天结束时，桌面上的不同数字有 2 、3 、4 、5 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3 </span><br><span class="line">输出：2</span><br><span class="line">解释： </span><br><span class="line">因为 3 % 2 == 1 ，2 也出现在桌面上。 </span><br><span class="line">在十亿天结束时，桌面上的不同数字只有两个：2 和 3 。 </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这道题是个简单题，一开始想着的是求每个出现在桌子上的数-1之后的因子，因为n最大就100，暴力解决</li><li>后来想想，不对，n一定会生成n-1，n-1之后会生成n-2 …..一直到生成2，这样实际上就是会有n-1个不同的数</li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distinctIntegers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2549-统计桌面上的不同数字&quot;&gt;&lt;a href=&quot;#2549-统计桌面上的不同数字&quot; class=&quot;headerlink&quot; title=&quot;2549. 统计桌面上的不同数字&quot;&gt;&lt;/a&gt;2549. 统计桌面上的不同数字&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="数学" scheme="https://coolling.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="简单" scheme="https://coolling.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>ICCD23-LightCheck</title>
    <link href="https://coolling.github.io/2024/03/21/ICCD23-LightCheck/"/>
    <id>https://coolling.github.io/2024/03/21/ICCD23-LightCheck/</id>
    <published>2024-03-21T12:25:21.000Z</published>
    <updated>2024-03-21T12:31:18.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LightCheck：A-Cost-Efﬁcient-Failure-Tolerant-Scheme-for-Distributed-DNN-Training"><a href="#LightCheck：A-Cost-Efﬁcient-Failure-Tolerant-Scheme-for-Distributed-DNN-Training" class="headerlink" title="LightCheck：A Cost-Efﬁcient Failure-Tolerant Scheme for Distributed DNN Training"></a>LightCheck：A Cost-Efﬁcient Failure-Tolerant Scheme for Distributed DNN Training</h1><p>ICCD23</p><p>为了减少检查点开销，我们通过逐层管道化检查点来利用细粒度异步检查点。</p><p>为了进一步减少检查点延迟，我们利用软件-硬件协同设计方法，通过持久内存 (PM) 管理器将新硬件设备合并到我们的检查点系统中。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>检查点在复制模型状态时需要阻塞训练—&gt;开销高</p><p>CheckFreq—-&gt;未能充分利用分布式DNN训练中计算、通信和检查点之间的并行性<br><img src="/../images/LightCheck/lightcheck-1.png" alt="checkfreq"></p><blockquote><p>整个模型状态一次连续复制</p><p>CheckFreq没有充分探究训练过程中的数据依赖性</p></blockquote><h2 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h2><p>LightCheck：为分布式 DNN 训练提供了低开销的频繁检查点。</p><p>a.LightCheck 以逐层方式将检查点与计算和通信进行管道化，从而减轻检查点对训练性能的影响。</p><p>b.有效地结合了PM的直接访问（DAX）功能和统一虚拟寻址（UVA）技术，将PM映射到GPU虚拟地址空间，从而允许从GPU直接访问PM。</p><p>c.进一步使用 CUDA流和事件通过 GPU 计算重叠 GPU-PM 数据传输。</p><p>d.为了提高 PM 写入吞吐量，LightCheck 将 PM 中张量元数据和张量数据的存储分开，从而使张量数据访问在小量写入时连续，在大量写入时对齐。</p><h2 id="LightCheck"><a href="#LightCheck" class="headerlink" title="LightCheck"></a>LightCheck</h2><p>由两个主要组件组成，包括高效的检查点方案和持久内存PM管理器</p><h3 id="检查点方案"><a href="#检查点方案" class="headerlink" title="检查点方案"></a><strong>检查点方案</strong></h3><blockquote><p>根据分布式训练过程中模型训练和检查点之间的数据依赖关系，异步checkpoint模型状态的最新更新部分</p></blockquote><p><strong>策略选择</strong></p><p>有三种不同的检查点策略，包括LightCheck-G、LightCheck-C和LightCheck-D</p><p>LightCheck-G:复制副本到GPU内存；从GPU内存写入PM【最小的快照时间；高GPU内存消耗】</p><p>LightCheck-C:复制副本到CPU内存；从CPU内存写入PM【干扰CPU中的运行进程】</p><p>LightCheck-D:直接将模型状态从GPU内存逐层传输到PM【PM带宽低；复杂的性能特征】【<strong>仔细地将检查点数据写入PM以充分利用PM带宽！</strong>】</p><p><strong>异步逐层检查点</strong><br><img src="/../images/LightCheck/lightcheck-2.png" alt="lightcheck"></p><p>将检查点与计算和通信进行管道化，以将检查点嵌入到训练数据流中。当某一层的梯度同步和参数更新完成后，该层的检查点就准备开始了。将检查点操作放入 FIFO 队列中，并使用后台线程异步执行它。</p><h3 id="持久内存管理器"><a href="#持久内存管理器" class="headerlink" title="持久内存管理器"></a><strong>持久内存管理器</strong></h3><blockquote><p>通过将PM映射到GPU虚拟内存空间并组织PM中检查点数据的存储位置，实现GPU内存和持久内存之间的有效数据传输。</p></blockquote><p><strong>三种技术</strong></p><p>a.直接内存访问 (DMA) 技术：它利用固定缓冲区作为主机内存和 GPU 内存之间数据传输的暂存区域</p><p>PM 的 DAX 功能：将 PM 直接映射到 CPU 地址空间</p><blockquote><p>可以通过 DMA 数据路径通过 cudaMemcpy API 在 PM 和 GPU 内存之间传输数据</p><p><strong>然而，通过DMA数据路径传输数据仍然需要经过CPU内存中的固定缓冲区，从而阻碍了传输性能。</strong></p></blockquote><p>b.统一内存（UM）技术，它进一步在全局内存地址空间中管理设备和主机内存，并自动在PM和GPU内存之间迁移内存页面。</p><blockquote><p>简化了编程，<strong>但仍然需要隐式页面迁移，这很难扩展统一内存以包含PM。</strong></p></blockquote><p>c.统一虚拟寻址（UVA）技术，它可以使用全局内存地址空间通过 PCIe 进行零拷贝访问</p><p>将PM映射到GPU虚拟地址空间</p><blockquote><p>该技术允许GPU内核在将PM映射到GPU虚拟地址空间后直接访问PM。</p><p><strong>与DMA和UM相比，UVA技术具有高性能并提高了易用性。</strong></p></blockquote><p>因此，我们使用 UVA 技术在 LightCheck 中的 PM 和 GPU 内存之间传输数据。</p><p>内存复制是通过使用后台线程在额外的 CUDA 流上执行的。</p><p>此外，由于训练需要检查检查点过程是否完成，LightCheck 通过 CUDA 事件监控 GPU-PM 内存复制的进度。</p><h3 id="检查点存储管理"><a href="#检查点存储管理" class="headerlink" title="检查点存储管理"></a>检查点存储管理</h3><p>对于检查点，除了张量元数据和一些附加状态（例如当前epoch、当前迭代和训练数据索引）之外，几乎所有数据都是以张量格式构造的</p><p>一般来说，检查点数据以字典的形式组织。在 PM 中复制和维护数据结构以匹配用于加载模型状态的训练框架接口（即load_state_dict()）非常重要。</p><blockquote><p>然而，由于 PM 对小随机写入敏感，因此通过 PCIe 接口的 GPU-PM 访问需要与 128 字节粒度保持一致，以实现更好的 PCIe 带宽利用率。</p><p>未对齐的访问会生成两个单独的 PCIe 请求，导致高 PM 写放大。</p></blockquote><p>LightCheck将检查点数据空间划分为数据映射区域和连续张量区域。</p><p>a.数据映射由PM中张量数据的地址和张量数据的字节数组成。</p><p>PM 中存储的数据映射可供所有 GPU 和 CPU 访问。基于UVA技术，PM中的每个张量都有一个供所有GPU和CPU使用的全局虚拟地址，处理器可以直接将张量写入PM中的相应位置。</p><p>在检查点文件初始化期间，LightCheck 分配 PM 空间并为张量创建数据映射。在PM中分配空间时，LightCheck按照访问顺序连续存储小张量数据，并在连续张量数据区域中以对齐的 PCIe 粒度为大于 128 字节的张量顺序分配内存。</p><blockquote><p>得益于分离的检查点存储管理，LightCheck可以显着缓解PM写入放大，并减少从GPU内存向PM写入检查点所需的PCIe请求数量。</p></blockquote><p>另外，LightCheck 仅为训练模型维护两个检查点数据映射。一旦一个检查点完成，另一个检查点就会被废弃。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LightCheck：A-Cost-Efﬁcient-Failure-Tolerant-Scheme-for-Distributed-DNN-Training&quot;&gt;&lt;a href=&quot;#LightCheck：A-Cost-Efﬁcient-Failure-Tolera</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://coolling.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="故障恢复" scheme="https://coolling.github.io/tags/%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/"/>
    
    <category term="ICCD" scheme="https://coolling.github.io/tags/ICCD/"/>
    
    <category term="23年" scheme="https://coolling.github.io/tags/23%E5%B9%B4/"/>
    
    <category term="检查点" scheme="https://coolling.github.io/tags/%E6%A3%80%E6%9F%A5%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2671.频率跟踪器</title>
    <link href="https://coolling.github.io/2024/03/21/2671-%E9%A2%91%E7%8E%87%E8%B7%9F%E8%B8%AA%E5%99%A8/"/>
    <id>https://coolling.github.io/2024/03/21/2671-%E9%A2%91%E7%8E%87%E8%B7%9F%E8%B8%AA%E5%99%A8/</id>
    <published>2024-03-21T04:47:01.000Z</published>
    <updated>2024-03-21T04:58:50.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1793-好子数组的最大分数"><a href="#1793-好子数组的最大分数" class="headerlink" title="1793. 好子数组的最大分数"></a>1793. 好子数组的最大分数</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。</p><p>实现 <code>FrequencyTracker</code> 类：</p><ul><li><code>FrequencyTracker()</code>：使用一个空数组初始化 <code>FrequencyTracker</code> 对象。</li><li><code>void add(int number)</code>：添加一个 <code>number</code> 到数据结构中。</li><li><code>void deleteOne(int number)</code>：从数据结构中删除一个 <code>number</code> 。数据结构 <strong>可能不包含</strong> <code>number</code> ，在这种情况下不删除任何内容。</li><li><code>bool hasFrequency(int frequency)</code>: 如果数据结构中存在出现 <code>frequency</code> 次的数字，则返回 <code>true</code>，否则返回 <code>false</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;FrequencyTracker&quot;, &quot;add&quot;, &quot;add&quot;, &quot;hasFrequency&quot;]</span><br><span class="line">[[], [3], [3], [2]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">FrequencyTracker frequencyTracker = new FrequencyTracker();</span><br><span class="line">frequencyTracker.add(3); // 数据结构现在包含 [3]</span><br><span class="line">frequencyTracker.add(3); // 数据结构现在包含 [3, 3]</span><br><span class="line">frequencyTracker.hasFrequency(2); // 返回 true ，因为 3 出现 2 次</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;FrequencyTracker&quot;, &quot;add&quot;, &quot;deleteOne&quot;, &quot;hasFrequency&quot;]</span><br><span class="line">[[], [1], [1], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, false]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">FrequencyTracker frequencyTracker = new FrequencyTracker();</span><br><span class="line">frequencyTracker.add(1); // 数据结构现在包含 [1]</span><br><span class="line">frequencyTracker.deleteOne(1); // 数据结构现在为空 []</span><br><span class="line">frequencyTracker.hasFrequency(1); // 返回 false ，因为数据结构为空</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;FrequencyTracker&quot;, &quot;hasFrequency&quot;, &quot;add&quot;, &quot;hasFrequency&quot;]</span><br><span class="line">[[], [2], [3], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, false, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">FrequencyTracker frequencyTracker = new FrequencyTracker();</span><br><span class="line">frequencyTracker.hasFrequency(2); // 返回 false ，因为数据结构为空</span><br><span class="line">frequencyTracker.add(3); // 数据结构现在包含 [3]</span><br><span class="line">frequencyTracker.hasFrequency(1); // 返回 true ，因为 3 出现 1 次</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= number &lt;= 105</code></li><li><code>1 &lt;= frequency &lt;= 105</code></li><li>最多调用 <code>add</code>、<code>deleteOne</code> 和 <code>hasFrequency</code> <strong>共计</strong> <code>2 * 105</code> 次</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目第一眼看是用map，做了一半之后发现是用数组……但其实用数组也是一样的，用两个数组，一个数字映射对应的频率，一个是频率映射对应的数字。</p><p>发现语法好多不会勒，忘了初始化的时候数组中不为0，要自己初始化</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FrequencyTracker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num[<span class="number">100001</span>] ;</span><br><span class="line">    <span class="type">int</span> frequencys[<span class="number">100001</span>] ;</span><br><span class="line">    <span class="built_in">FrequencyTracker</span>() &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100001</span>;i++)&#123;</span><br><span class="line">        num[i]=<span class="number">0</span>;</span><br><span class="line">        frequencys[i]=<span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        frequencys[num[number]]--;</span><br><span class="line">        num[number]++;</span><br><span class="line">        frequencys[num[number]]++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteOne</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[number]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            frequencys[num[number]]--;</span><br><span class="line">            num[number]--;</span><br><span class="line">            frequencys[num[number]]++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasFrequency</span><span class="params">(<span class="type">int</span> frequency)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> frequencys[frequency]&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1793-好子数组的最大分数&quot;&gt;&lt;a href=&quot;#1793-好子数组的最大分数&quot; class=&quot;headerlink&quot; title=&quot;1793. 好子数组的最大分数&quot;&gt;&lt;/a&gt;1793. 好子数组的最大分数&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="中等" scheme="https://coolling.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="哈希" scheme="https://coolling.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>1793. 好子数组的最大分数</title>
    <link href="https://coolling.github.io/2024/03/19/1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/"/>
    <id>https://coolling.github.io/2024/03/19/1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/</id>
    <published>2024-03-19T08:40:32.000Z</published>
    <updated>2024-03-19T09:05:05.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1793-好子数组的最大分数"><a href="#1793-好子数组的最大分数" class="headerlink" title="1793. 好子数组的最大分数"></a>1793. 好子数组的最大分数</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个整数数组 <code>nums</code> <strong>（下标从 0 开始）</strong>和一个整数 <code>k</code> 。</p><p>一个子数组 <code>(i, j)</code> 的 <strong>分数</strong> 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code> 。一个 <strong>好</strong> 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。</p><p>请你返回 <strong>好</strong> 子数组的最大可能 <strong>分数</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,4,3,7,4,5], k = 3</span><br><span class="line">输出：15</span><br><span class="line">解释：最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,5,4,5,4,1,1,1], k = 0</span><br><span class="line">输出：20</span><br><span class="line">解释：最优子数组的左右端点下标是 (0, 4) ，分数为 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 104</code></li><li><code>0 &lt;= k &lt; nums.length</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这种题型还挺经典的，双指针。</p><ol><li><p>因为题目给定了一个k要在范围内，所以很自然地，i和j两个指针可以从k的两边开始遍历。</p></li><li><p>为了最大化<code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code>,i和j分别向两边移动，以增加<code>(j - i + 1)</code>。</p></li><li><p>但是在增加的过程中，如果遇到一些更小的数，反而会减少<code>min(nums[i], nums[i+1], ..., nums[j])</code>。这个时候就要决定怎么扩展，移动<code>i</code>还是移动<code>j</code>？应该移动num[i]和num[j]更大的那一个，这是很显然的，我浅浅证明一下：</p><p>a.当num[i-1]和num[j+1]都大于min的情况下，移动i和移动j都一样</p><p>b.当num[i-1]和num[j+1]都小于min的情况下，假如num[i-1]&lt;num[j+1]，移动哪个都会使min更新，移动向num[j+1]，结果为num[j+1] (j - i + 1)；移动向num[i-1]，结果为num[i-1] (j - i + 1)。显然，移动j得到的结果num[j+1] (j - i + 1)会更大，因为num[i-1]&lt;num[j+1]</p><p>c.当num[i-1]和num[j+1]一个小于min，一个大于min,很显然，移动较大的那个不会使min减小。</p></li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=k;</span><br><span class="line">        <span class="type">int</span> j=k;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum=nums[k];</span><br><span class="line">        <span class="type">int</span> min=nums[k];</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">while</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;j+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">            <span class="comment">//在选择扩展i-1或者j+1时，选择扩展更大的那个</span></span><br><span class="line">            t=nums[j+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&gt;=nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                t=nums[i<span class="number">-1</span>];</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">            <span class="comment">//更新最小值</span></span><br><span class="line">            <span class="keyword">if</span> (min &gt; t)</span><br><span class="line">                min=t;</span><br><span class="line">            <span class="comment">//更新结果</span></span><br><span class="line">            <span class="keyword">if</span>(min*(j-i+<span class="number">1</span>)&gt;sum)</span><br><span class="line">                sum=min*(j-i+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//跳出循环后，检查一下左边是否遍历完</span></span><br><span class="line">        <span class="keyword">while</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            t=nums[i<span class="number">-1</span>];</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; t)</span><br><span class="line">                min=t;</span><br><span class="line">            <span class="keyword">if</span>(min*(j-i+<span class="number">1</span>)&gt;sum)</span><br><span class="line">                sum=min*(j-i+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//跳出循环后，检查一下右边是否遍历完</span></span><br><span class="line">        <span class="keyword">while</span>(j+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">            t=nums[j+<span class="number">1</span>];</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; t)</span><br><span class="line">                min=t;</span><br><span class="line">            <span class="keyword">if</span>(min*(j-i+<span class="number">1</span>)&gt;sum)</span><br><span class="line">                sum=min*(j-i+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>贴上官方解答，其实是一个意思，但是写的好简洁，再学习一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = k - <span class="number">1</span>, right = k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums[k];;) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; nums[left] &gt;= i) &#123;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; n &amp;&amp; nums[right] &gt;= i) &#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right - left - <span class="number">1</span>) * i);</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="number">-1</span> &amp;&amp; right == n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = <span class="built_in">max</span>((left == <span class="number">-1</span> ? <span class="number">-1</span> : nums[left]), (right == n ? <span class="number">-1</span> : nums[right]));</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/maximum-score-of-a-good-subarray/solutions/2688286/hao-zi-shu-zu-de-zui-da-fen-shu-by-leetc-94gx/">https://leetcode.cn/problems/maximum-score-of-a-good-subarray/solutions/2688286/hao-zi-shu-zu-de-zui-da-fen-shu-by-leetc-94gx/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1793-好子数组的最大分数&quot;&gt;&lt;a href=&quot;#1793-好子数组的最大分数&quot; class=&quot;headerlink&quot; title=&quot;1793. 好子数组的最大分数&quot;&gt;&lt;/a&gt;1793. 好子数组的最大分数&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="困难" scheme="https://coolling.github.io/tags/%E5%9B%B0%E9%9A%BE/"/>
    
    <category term="双指针" scheme="https://coolling.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>303. 区域和检索 - 数组不可变</title>
    <link href="https://coolling.github.io/2024/03/18/303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <id>https://coolling.github.io/2024/03/18/303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</id>
    <published>2024-03-18T06:23:23.000Z</published>
    <updated>2024-03-18T06:30:05.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303.区域和检索 - 数组不可变"></a>303.区域和检索 - 数组不可变</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给定一个整数数组  <code>nums</code>，处理以下类型的多个查询:</p><ol><li>计算索引 <code>left</code> 和 <code>right</code> （包含 <code>left</code> 和 <code>right</code>）之间的 <code>nums</code> 元素的 <strong>和</strong> ，其中 <code>left &lt;= right</code></li></ol><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 中索引 <code>left</code> 和 <code>right</code> 之间的元素的 <strong>总和</strong> ，包含 <code>left</code> 和 <code>right</code> 两点（也就是 <code>nums[left] + nums[left + 1] + ... + nums[right]</code> )</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)</span><br><span class="line">numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) </span><br><span class="line">numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li><li><code>0 &lt;= i &lt;= j &lt; nums.length</code></li><li>最多调用 <code>104</code> 次 <code>sumRange</code> 方法</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这一题乍一看，嘿，不就是求和嘛，一个简单题。提交之后也过了，看看题解之后感觉自己还是想的太少了….</p><p>题解的思路是每个位置放的是前面数字的和，因此当调用sumRange的时候只需要两个位置相剪，时间复杂度是O(1) ,而我的每次都要求和，时间复杂度是O(n)。学到了ww</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;  num;</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">//拷贝初始化</span></span><br><span class="line">        num=nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            sum+=num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>贴上官方解答</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sums;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sums.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j + <span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/range-sum-query-immutable/solutions/627052/qu-yu-he-jian-suo-shu-zu-bu-ke-bian-by-l-px41/">https://leetcode.cn/problems/range-sum-query-immutable/solutions/627052/qu-yu-he-jian-suo-shu-zu-bu-ke-bian-by-l-px41/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;303-区域和检索-数组不可变&quot;&gt;&lt;a href=&quot;#303-区域和检索-数组不可变&quot; class=&quot;headerlink&quot; title=&quot;303.区域和检索 - 数组不可变&quot;&gt;&lt;/a&gt;303.区域和检索 - 数组不可变&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="简单" scheme="https://coolling.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="前缀和" scheme="https://coolling.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>ppopp23-SWIFT: Expedited Failure Recovery for Large-scale DNN Training</title>
    <link href="https://coolling.github.io/2024/03/17/ppopp23-SWIFT-Expedited-Failure-Recovery-for-Large-scale-DNN-Training/"/>
    <id>https://coolling.github.io/2024/03/17/ppopp23-SWIFT-Expedited-Failure-Recovery-for-Large-scale-DNN-Training/</id>
    <published>2024-03-17T12:42:06.000Z</published>
    <updated>2024-03-21T12:26:04.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SWIFT-Expedited-Failure-Recovery-for-Large-scale-DNN-Training"><a href="#SWIFT-Expedited-Failure-Recovery-for-Large-scale-DNN-Training" class="headerlink" title="SWIFT: Expedited Failure Recovery for Large-scale DNN Training"></a>SWIFT: Expedited Failure Recovery for Large-scale DNN Training</h1><p>PPoPP’23</p><p>SWIFT 不是制作模型状态的额外副本，而是解决由故障引起的模型状态的不一致，并利用数据并行性中的模型状态副本进行故障恢复。对于流水线并行，提出了一种基于日志记录的方法，该方法记录中间数据并重播计算以在发生故障时恢复丢失的状态。</p><p><strong>问题：</strong>目前的检查点方法需要进行一个快照操作—将模型状态保存在内存—-减慢训练速度，内存成本高</p><p><strong>解决：</strong></p><p>1.数据并行发生故障时，有的机器已经完成了参数更新，机器之间状态不一致—崩溃一致性问题</p><p>发现：模型状态更新的许多优化器在数学上是可逆的。</p><p>通过<strong>撤消</strong>参数的更新来将幸存worker的模型状态恢复到一致状态，用幸存worker中模型状态的副本进行恢复</p><p>2.对于流水线并行</p><p>使用日志，记录机器间通信数据，异步执行日志记录，将数据存储在后台。</p><p>发生故障时，检索日志数据并重播计算。</p><p>可以将日志数据传播给幸存worker，让他们协助恢复。</p><p>以及进一步利用worker的空闲时间（即管道并行性中的冒泡时间）来进行日志记录。</p><p>使用分组来减少记录的日志量</p><h2 id="SWIFT"><a href="#SWIFT" class="headerlink" title="SWIFT"></a>SWIFT</h2><p>a.模型并行—使用副本恢复</p><p>b.流水线并行—使用基于日志的恢复【流水线并行中的通信数据量远小于数据并行和模型并行；数据并行和模型并行使用集合通信，管道并行是点对点通信，比较简单】</p><p>c.以上都不满足，仅使用全局检查点</p><p>当检测到故障：</p><p>1.替换机器</p><p>2.幸存worker使用更新撤销解决模型状态不一致问题</p><p>3.执行恢复替换失败的worker</p><p>基于副本的恢复：幸存worker将模型状态广播给新worker</p><p>基于日志的恢复：替换worker加载最新的检查点，然后根据日志数据重新计算丢失的迭代，直到恢复到故障前的迭代</p><h2 id="更新撤销"><a href="#更新撤销" class="headerlink" title="更新撤销"></a>更新撤销</h2><p>优化器的许多更新运算符在数学上是可逆的，即对于运算符 f ，存在一个逆运算符 f -1 可以撤销 f 的操作。</p><p><img src="/../images/swift/swift-1.png" alt="img"></p><h2 id="基于日志记录的恢复"><a href="#基于日志记录的恢复" class="headerlink" title="基于日志记录的恢复"></a>基于日志记录的恢复</h2><p>机器故障比单GPU故障更常见，因此我们不记录机器内的 GPU 到 GPU 的通信，<strong>而只记录机器间的通信</strong>，从而大大减少了日志记录开销</p><p>a.记录什么数据？</p><p>要记录的数据包括<strong>前向传递中的中间激活和后向传递中的梯度</strong>。<strong>要记录一些元数据，包括发送者和接收者以及时间戳</strong>（其中包含当前训练迭代和当前正在训练的微批次的标识符）</p><p>b.怎么记录数据</p><p>发送者记录消息，在后台异步记录它。为每个worker设置一个队列。在训练期间，工作线程不断将传出张量推入队列，而另一个后台线程不断从队列中读取张量并进行日志记录。</p><p>c.日志记录开销怎么办</p><p>同步流水线并行训练中，存在许多气泡，期间工作线程处于空闲状态，这是记录日志的理想时间。</p><p>一旦日志数据传输到CPU，GPU上的数据就可以安全地删除，不会导致 GPU 上大量数据积累</p><p><img src="/../images/swift/swift-2.png" alt="img"></p><p>d.如何恢复</p><p><img src="/../images/swift/swift-3.png" alt="img"></p><p>前一个worker先将未记录的日志数据记录到cpu，然后写入disk，然后上传到全局存储；新机器将其所需的日志文件从全局存储下载到本地磁盘，加载最新的检查点，并按照时间戳的确切顺序重播之前从日志文件接收到的张量</p><p>【<strong>恢复范围仅限于故障机器上的本地计算图，而不是整个计算图，从而加快了恢复速度。</strong>】</p><p>e.垃圾收集</p><p>所有早期的日志文件在全局检查点之后都会被废弃，并且垃圾会被收集，因为系统可以直接加载最新的检查点。尽管日志记录大小随着迭代次数的增加而增加，但由于定期全局检查点，该大小是有上限的。因此，全局检查点的频率决定了日志记录大小的上限。</p><p>f.并行恢复</p><p>利用幸存的worker来协助恢复的worker。所有worker（包括替代worker和幸存worker）都会检索日志文件并拥有故障机器计算图的副本。每个worker从日志文件中读取不同微批次的日志数据，并将它们作为输入重新计算梯度，与计算其他微批次的其他worker同步梯度，然后执行模型更新。这样，多个worker可以并行地为故障机器重新计算微批次，从而加速恢复</p><p><img src="/../images/swift/swift-4.png" alt="img"></p><p>替代worker从最新的检查点加载模型状态并将其状态广播给幸存的worker，所有worker从全局存储下载日志文件，选择相应微批次的日志数据进行重新计算。恢复后，幸存的worker加载其检查点以恢复其原始模型参数和优化器状态</p><p>g.选择性记录</p><p>记录所有跨机器消息可能会消耗大量存储空间。通过选择性日志记录来研究存储空间和恢复时间之间的权衡。</p><p><strong>将机器分组并记录组间通信，但不记录组内通信</strong>。我们可以将原始方法视为一种特殊情况，其中每台机器形成一个组。如果组中的一台机器发生故障，则整个组机器的训练需要从最新的检查点回滚，因为我们不记录组内通信。</p><p>选择性日志记录以恢复时间换取空间开销。</p><p><strong>考虑到日志数据的存储容量限制，我们如何对机器进行分组以最小化故障恢复时间？</strong></p><p>1.分析了每个组 Gi 的平均每次迭代计算时间 R(Gi)</p><p>2.对于每对相邻组,获得它们之间每次迭代的传输大小</p><p>3.在存储容量限制 Mmax、网络带宽 B 和检查点间隔 T的情况下，我们的目标是找到一个组配置 G &#x3D; {G1,…。 。 。 , Gk} 最小化总体恢复时间 R</p><p>4.推断合并之后总体恢复时间 R 和总体空间开销 M 的变化</p><p>5.迭代地合并具有最小 ΔR&#x2F;ΔM 的两个相邻组，直到总体空间消耗小于 Mmax。（<strong>最小化每单位存储空间减少而增加的恢复时间</strong>）其中M（G）表示日志数据所需的总体存储空间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SWIFT-Expedited-Failure-Recovery-for-Large-scale-DNN-Training&quot;&gt;&lt;a href=&quot;#SWIFT-Expedited-Failure-Recovery-for-Large-scale-DNN-Traini</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://coolling.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="故障恢复" scheme="https://coolling.github.io/tags/%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/"/>
    
    <category term="23年" scheme="https://coolling.github.io/tags/23%E5%B9%B4/"/>
    
    <category term="PPoPP" scheme="https://coolling.github.io/tags/PPoPP/"/>
    
    <category term="日志" scheme="https://coolling.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>310.最小高度树</title>
    <link href="https://coolling.github.io/2024/03/17/310-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"/>
    <id>https://coolling.github.io/2024/03/17/310-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</id>
    <published>2024-03-17T08:39:30.000Z</published>
    <updated>2024-03-17T13:17:54.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="310-最小高度树"><a href="#310-最小高度树" class="headerlink" title="310.最小高度树"></a>310.最小高度树</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。</p><p>给你一棵包含 <code>n</code> 个节点的树，标记为 <code>0</code> 到 <code>n - 1</code> 。给定数字 <code>n</code> 和一个有 <code>n - 1</code> 条无向边的 <code>edges</code> 列表（每一个边都是一对标签），其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间存在一条无向边。</p><p>可选择树中任何一个节点作为根。当选择节点 <code>x</code> 作为根节点时，设结果树的高度为 <code>h</code> 。在所有可能的树中，具有最小高度的树（即，<code>min(h)</code>）被称为 <strong>最小高度树</strong> 。</p><p>请你找到所有的 <strong>最小高度树</strong> 并按 <strong>任意顺序</strong> 返回它们的根节点标签列表。</p><p>树的 <strong>高度</strong> 是指根节点和叶子节点之间最长向下路径上边的数量。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, edges = [[1,0],[1,2],[1,3]]</span><br><span class="line">输出：[1]</span><br><span class="line">解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>edges.length == n - 1</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>ai != bi</code></li><li>所有 <code>(ai, bi)</code> 互不相同</li><li>给定的输入 <strong>保证</strong> 是一棵树，并且 <strong>不会有重复的边</strong></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题虽然是中档题，但是做的时候出了各种问题….心态崩了…</p><ol><li><p>首先<strong>暴力解法</strong>，就是以每一个点为根做树，做广度遍历分别求出每棵树的深度值，以深度最小的节点为根</p></li><li><p>另一个思路是求出这棵树中的最长路径，我们要找的根结点就在这棵树的中间。那如何寻找最长路径呢，我看答案的…</p><p>思路就是：</p><p><strong>以任意节点 p出发，利用广度优先搜索或者深度优先搜索找到以 p 为起点的最长路径的终点 x；</strong></p><p><strong>以节点 x 出发，找到以 x 为起点的最长路径的终点 y；</strong></p><p>x 到 y 之间的路径即为图中的最长路径，找到路径的中间节点即为根节点。</p><p>证明：<a href="https://oi-wiki.org/graph/tree-diameter/">https://oi-wiki.org/graph/tree-diameter/</a></p><p>定理：在一棵树上，从任意节点 y 开始进行一次 DFS，到达的距离其最远的节点 z 必为直径的一端。</p><p><img src="/../images/leetcode/image-20240317170041756.png" alt="定理证明-反证法"></p></li><li><p>另一个问题是<strong>内存问题</strong>，我一开始是把edges转化为n*n大小的矩阵的，矩阵中的值为0&#x2F;1，代表是否连接，结果内存超过了，我就改成n个vector，vector里面存的是连接的节点。</p></li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 广度遍历</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLongPath</span><span class="params">(<span class="type">int</span> root,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; con,vector&lt;<span class="type">int</span>&gt;&amp;parent)</span></span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="type">int</span> n=con.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        visited[root]=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> node=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            node=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> s=con[node].<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                <span class="type">int</span> a=con[node][i];</span><br><span class="line">                <span class="keyword">if</span>(visited[a]==<span class="literal">false</span>)&#123;    </span><br><span class="line">                    q.<span class="built_in">push</span>(a);</span><br><span class="line">                    visited[a]=<span class="literal">true</span>;</span><br><span class="line">                    parent[a]=node;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">con</span>(n);</span><br><span class="line">        <span class="type">int</span> m = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            con[edges[i][<span class="number">0</span>]].<span class="built_in">push_back</span>(edges[i][<span class="number">1</span>]);</span><br><span class="line">            con[edges[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(edges[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">findLongPath</span>(<span class="number">0</span>,con,parent);</span><br><span class="line">        <span class="type">int</span> y=<span class="built_in">findLongPath</span>(x,con,parent);</span><br><span class="line">        parent[x]=<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 路径长度</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;re;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(y!=<span class="number">-1</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            re.<span class="built_in">push_back</span>(y);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">            y=parent[y];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(re.<span class="built_in">size</span>()%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;re[re.<span class="built_in">size</span>()/<span class="number">2</span>]&#125;;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> &#123;re[re.<span class="built_in">size</span>()/<span class="number">2</span>],re[re.<span class="built_in">size</span>()/<span class="number">2</span><span class="number">-1</span>]&#125;;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;310-最小高度树&quot;&gt;&lt;a href=&quot;#310-最小高度树&quot; class=&quot;headerlink&quot; title=&quot;310.最小高度树&quot;&gt;&lt;/a&gt;310.最小高度树&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="中等" scheme="https://coolling.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="bfs" scheme="https://coolling.github.io/tags/bfs/"/>
    
    <category term="树" scheme="https://coolling.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>2684. 矩阵中移动的最大次数</title>
    <link href="https://coolling.github.io/2024/03/16/2684-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0/"/>
    <id>https://coolling.github.io/2024/03/16/2684-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0/</id>
    <published>2024-03-16T06:50:12.000Z</published>
    <updated>2024-03-17T13:17:47.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2684-矩阵中移动的最大次数"><a href="#2684-矩阵中移动的最大次数" class="headerlink" title="2684.矩阵中移动的最大次数"></a>2684.矩阵中移动的最大次数</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的矩阵 <code>grid</code> ，矩阵由若干 <strong>正</strong> 整数组成。</p><p>你可以从矩阵第一列中的 <strong>任一</strong> 单元格出发，按以下方式遍历 <code>grid</code> ：</p><ul><li>从单元格 <code>(row, col)</code> 可以移动到 <code>(row - 1, col + 1)</code>、<code>(row, col + 1)</code> 和 <code>(row + 1, col + 1)</code> 三个单元格中任一满足值 <strong>严格</strong> 大于当前单元格的单元格。</li></ul><p>返回你在矩阵中能够 <strong>移动</strong> 的 <strong>最大</strong> 次数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以从单元格 (0, 0) 开始并且按下面的路径移动：</span><br><span class="line">- (0, 0) -&gt; (0, 1).</span><br><span class="line">- (0, 1) -&gt; (1, 2).</span><br><span class="line">- (1, 2) -&gt; (2, 3).</span><br><span class="line">可以证明这是能够移动的最大次数。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[3,2,4],[2,1,9],[1,1,7]]</span><br><span class="line">输出：0</span><br><span class="line">解释：从第一列的任一单元格开始都无法移动。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>2 &lt;= m, n &lt;= 1000</code></li><li><code>4 &lt;= m * n &lt;= 105</code></li><li><code>1 &lt;= grid[i][j] &lt;= 106</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题可以使用动态规划来解答，很明显如果周围有某个格子i可以移动，那么当前格子向i移动可以进行的移动步数为count(i)+1。这题需要注意的一点是，它的出发点是第一列的任意一个，我一开始想当然地以为是（0，0）了。</p><p>官方解答使用的方法是bfs。我重新看了一下题目，原来那3个格子意味着只能向下一列移动，有点像是3叉树的感觉了。不过思考了一下，时间复杂度的话是一样的O(mn)，空间复杂度就差了，我的空间复杂度也是O(mn)，官方题解是O(n)。</p><p>官方题解的思路是，一开始把第一列的行都记录下来，从左到右遍历这些列，每到一列，判断哪些行可以继续走到下一列，直到到达最后一列或者行都没了。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; count,<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">int</span> m,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row&lt;<span class="number">0</span>||row&gt;=m||col&lt;<span class="number">0</span>||col&gt;=n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count[row][col]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> count[row][col];</span><br><span class="line">        <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> temp=<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//(row - 1, col + 1)</span></span><br><span class="line">        <span class="keyword">if</span>(row<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;col+<span class="number">1</span>&lt;n&amp;&amp;grid[row][col]&lt;grid[row - <span class="number">1</span>][col + <span class="number">1</span>])&#123;</span><br><span class="line">            temp=<span class="number">1</span>+<span class="built_in">getResult</span>(grid,count,row - <span class="number">1</span>, col + <span class="number">1</span>,m,n);</span><br><span class="line">            <span class="keyword">if</span> (temp&gt;re)</span><br><span class="line">                re=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(row, col + 1)</span></span><br><span class="line">        <span class="keyword">if</span>(col+<span class="number">1</span>&lt;n&amp;&amp;grid[row][col]&lt;grid[row][col + <span class="number">1</span>])&#123;</span><br><span class="line">            temp=<span class="number">1</span>+<span class="built_in">getResult</span>(grid,count,row , col + <span class="number">1</span>,m,n);</span><br><span class="line">            <span class="keyword">if</span> (temp&gt;re)</span><br><span class="line">                re=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(row + 1, col + 1)</span></span><br><span class="line">        <span class="keyword">if</span>(row+<span class="number">1</span>&lt;m&amp;&amp;col+<span class="number">1</span>&lt;n&amp;&amp;grid[row][col]&lt;grid[row + <span class="number">1</span>][col + <span class="number">1</span>])&#123;</span><br><span class="line">            temp=<span class="number">1</span>+<span class="built_in">getResult</span>(grid,count,row + <span class="number">1</span>, col + <span class="number">1</span>,m,n);</span><br><span class="line">            <span class="keyword">if</span> (temp&gt;re)</span><br><span class="line">                re=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        count[row][col]=re;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxMoves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">count</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">-1</span>));</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=<span class="built_in">getResult</span>(grid,count,i,<span class="number">0</span>,m,n);</span><br><span class="line">            <span class="keyword">if</span> (temp&gt;max)</span><br><span class="line">                max=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还是贴上官方解答，写的比我简洁多了，学习一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxMoves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; q, q2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            q.<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            q2.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : q) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i2 = i - <span class="number">1</span>; i2 &lt;= i + <span class="number">1</span>; i2++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= i2 &amp;&amp; i2 &lt; m &amp;&amp; grid[i][j - <span class="number">1</span>] &lt; grid[i2][j]) &#123;</span><br><span class="line">                        q2.<span class="built_in">insert</span>(i2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(q, q2);</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/solutions/2684036/ju-zhen-zhong-yi-dong-de-zui-da-ci-shu-b-b7jx/">https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/solutions/2684036/ju-zhen-zhong-yi-dong-de-zui-da-ci-shu-b-b7jx/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2684-矩阵中移动的最大次数&quot;&gt;&lt;a href=&quot;#2684-矩阵中移动的最大次数&quot; class=&quot;headerlink&quot; title=&quot;2684.矩阵中移动的最大次数&quot;&gt;&lt;/a&gt;2684.矩阵中移动的最大次数&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="中等" scheme="https://coolling.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="动态规划" scheme="https://coolling.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="bfs" scheme="https://coolling.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>2789.合并后数组中的最大元素</title>
    <link href="https://coolling.github.io/2024/03/14/2789-%E5%90%88%E5%B9%B6%E5%90%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>https://coolling.github.io/2024/03/14/2789-%E5%90%88%E5%B9%B6%E5%90%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</id>
    <published>2024-03-14T09:12:09.000Z</published>
    <updated>2024-03-17T13:17:40.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2789-合并后数组中的最大元素"><a href="#2789-合并后数组中的最大元素" class="headerlink" title="2789.合并后数组中的最大元素"></a>2789.合并后数组中的最大元素</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个下标从 <strong>0</strong> 开始、由正整数组成的数组 <code>nums</code> 。</p><p>你可以在数组上执行下述操作 <strong>任意</strong> 次：</p><ul><li>选中一个同时满足 <code>0 &lt;= i &lt; nums.length - 1</code> 和 <code>nums[i] &lt;= nums[i + 1]</code> 的整数 <code>i</code> 。将元素 <code>nums[i + 1]</code> 替换为 <code>nums[i] + nums[i + 1]</code> ，并从数组中删除元素 <code>nums[i]</code> 。</li></ul><p>返回你可以从最终数组中获得的 <strong>最大</strong> 元素的值。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,7,9,3]</span><br><span class="line">输出：21</span><br><span class="line">解释：我们可以在数组上执行下述操作：</span><br><span class="line">- 选中 i = 0 ，得到数组 nums = [5,7,9,3] 。</span><br><span class="line">- 选中 i = 1 ，得到数组 nums = [5,16,3] 。</span><br><span class="line">- 选中 i = 0 ，得到数组 nums = [21,3] 。</span><br><span class="line">最终数组中的最大元素是 21 。可以证明我们无法获得更大的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,3,3]</span><br><span class="line">输出：11</span><br><span class="line">解释：我们可以在数组上执行下述操作：</span><br><span class="line">- 选中 i = 1 ，得到数组 nums = [5,6] 。</span><br><span class="line">- 选中 i = 0 ，得到数组 nums = [11] 。</span><br><span class="line">最终数组中只有一个元素，即 11 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^6</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先，因为nums的长度可以到10^5^，每个数最大 10^6^，因此结果最大可到 10^11^，因此使用<code>long long</code>类型。</p><p>为了求得合并后的最大数字，我们想要尽可能地多合并几次。很显然，应该从后面往前合并比较合适。</p><p>（1）因此如果前面几个比较小的数字合并起来超过了后面原本比他们都大的某个数，后面的数字就无法往前合并了。</p><p>（2）而我们从后面往前面合并的话，合并的条件是<code>nums[i] &lt;= nums[i + 1]</code>，从后面开始合并<code>nums[i + 1]</code>只会大于等于未合并前的数字，不会影响本来可以合并的情况。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxArrayValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1 &lt;= nums.length &lt;= 105</span></span><br><span class="line">        <span class="comment">//1 &lt;= nums[i] &lt;= 106</span></span><br><span class="line">        <span class="comment">//所以要考虑10的11次方的大小，应该用long long</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> size=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> now=nums[size<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=size<span class="number">-1</span>;i&gt;<span class="number">0</span>;--i)</span><br><span class="line">            <span class="keyword">if</span>(now&gt;=nums[i<span class="number">-1</span>])</span><br><span class="line">                now+=nums[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(now&gt;max)</span><br><span class="line">                    max=now;</span><br><span class="line">                now=nums[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(now&gt;max)</span><br><span class="line">            max=now;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还是贴上官方解答，写的比我简洁多了，学习一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxArrayValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = nums.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sum = nums[i] &lt;= sum ? nums[i] + sum : nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/largest-element-in-an-array-after-merge-operations/submissions/511757169/">https://leetcode.cn/problems/largest-element-in-an-array-after-merge-operations/submissions/511757169/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2789-合并后数组中的最大元素&quot;&gt;&lt;a href=&quot;#2789-合并后数组中的最大元素&quot; class=&quot;headerlink&quot; title=&quot;2789.合并后数组中的最大元素&quot;&gt;&lt;/a&gt;2789.合并后数组中的最大元素&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="中等" scheme="https://coolling.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="贪心" scheme="https://coolling.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>2864.最大二进制奇数</title>
    <link href="https://coolling.github.io/2024/03/13/%E6%9C%80%E5%A4%A7%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A5%87%E6%95%B0/"/>
    <id>https://coolling.github.io/2024/03/13/%E6%9C%80%E5%A4%A7%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A5%87%E6%95%B0/</id>
    <published>2024-03-13T10:23:33.000Z</published>
    <updated>2024-03-17T13:17:35.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2864-最大二进制奇数"><a href="#2864-最大二进制奇数" class="headerlink" title="2864.最大二进制奇数"></a>2864.最大二进制奇数</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个 <strong>二进制</strong> 字符串 <code>s</code> ，其中至少包含一个 <code>&#39;1&#39;</code> 。</p><p>你必须按某种方式 <strong>重新排列</strong> 字符串中的位，使得到的二进制数字是可以由该组合生成的 <strong>最大二进制奇数</strong> 。</p><p>以字符串形式，表示并返回可以由给定组合生成的最大二进制奇数。</p><p><strong>注意</strong> 返回的结果字符串 <strong>可以</strong> 含前导零。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;010&quot;</span><br><span class="line">输出：&quot;001&quot;</span><br><span class="line">解释：因为字符串 s 中仅有一个 &#x27;1&#x27; ，其必须出现在最后一位上。所以答案是 &quot;001&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0101&quot;</span><br><span class="line">输出：&quot;1001&quot;</span><br><span class="line">解释：其中一个 &#x27;1&#x27; 必须出现在最后一位上。而由剩下的数字可以生产的最大数字是 &quot;100&quot; 。所以答案是 &quot;1001&quot; 。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>要获得最大的二进制数思路，只需要将原来二进制串中的 ’1‘都移到最前面。但是要的是奇数，所以要留一个’1‘在二进制串的最后面。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">maximumOddBinaryNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len =s.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> count1=<span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 获取字符串中1的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch : s)&#123;</span><br><span class="line">            count1+=ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将‘1’放到前面</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count1<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            res+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len-count1;i++)&#123;</span><br><span class="line">            res+=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 留一个‘1’在最后 确保是奇数</span></span><br><span class="line">        res+=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好久没有写c++了，对一些语法生疏了起来，看了题解，可以用更简洁的代码来完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">maximumOddBinaryNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// algorithm头文件定义了一个count的函数。这个函数使用一对迭代器和一个值做参数，返回这个值出现次数的统计结果。</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="comment">// string(size_type n,char c) ：创建一个包含 n 个元素的 string 对象，其中每个元素都被初始化为字符 c</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(cnt - <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>) + <span class="built_in">string</span>(s.<span class="built_in">length</span>() - cnt, <span class="string">&#x27;0&#x27;</span>) + <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/maximum-odd-binary-number/solutions/2679827/zui-da-de-er-jin-zhi-qi-shu-by-leetcode-1mi14/">https://leetcode.cn/problems/maximum-odd-binary-number/solutions/2679827/zui-da-de-er-jin-zhi-qi-shu-by-leetcode-1mi14/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2864-最大二进制奇数&quot;&gt;&lt;a href=&quot;#2864-最大二进制奇数&quot; class=&quot;headerlink&quot; title=&quot;2864.最大二进制奇数&quot;&gt;&lt;/a&gt;2864.最大二进制奇数&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="简单" scheme="https://coolling.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="贪心" scheme="https://coolling.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://coolling.github.io/2024/03/13/hello-world/"/>
    <id>https://coolling.github.io/2024/03/13/hello-world/</id>
    <published>2024-03-13T09:49:05.899Z</published>
    <updated>2024-03-13T09:49:05.899Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
