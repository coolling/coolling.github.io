<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coolling</title>
  
  
  <link href="https://coolling.github.io/atom.xml" rel="self"/>
  
  <link href="https://coolling.github.io/"/>
  <updated>2024-10-02T09:08:49.751Z</updated>
  <id>https://coolling.github.io/</id>
  
  <author>
    <name>Coolling</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划1</title>
    <link href="https://coolling.github.io/2024/10/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921/"/>
    <id>https://coolling.github.io/2024/10/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921/</id>
    <published>2024-10-02T08:56:21.000Z</published>
    <updated>2024-10-02T09:08:49.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法题-动态规划"><a href="#算法题-动态规划" class="headerlink" title="算法题-动态规划"></a>算法题-动态规划</h1><p>来自<strong>LeetCode 热题 100</strong></p><p>国庆水几题嘿嘿</p><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>好经典的题，大概就是f(n)&#x3D;f(n-1)+f(n-2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                a=a+b;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b=a+b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="杨辉三角形"><a href="#杨辉三角形" class="headerlink" title="杨辉三角形"></a>杨辉三角形</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numRows = 5</span><br><span class="line">输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numRows = 1</span><br><span class="line">输出: [[1]]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>经典题+1，转移式：re[i] [j]&#x3D;re[i-1] [j-1]+re[i-1] [j]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">re</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>||j==i)&#123;</span><br><span class="line">                    </span><br><span class="line">                    re[i].<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    re[i].<span class="built_in">emplace_back</span>(re[i<span class="number">-1</span>][j<span class="number">-1</span>]+re[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>好像给做复杂了，这道题想的是对一个房子有能偷和不能偷两种可能，能不能偷又取决于前面，能偷的话就是前一个房子不偷的最大值加上这个房子的价值；不能偷的话就是前一个房子偷和不偷的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">m</span>(size,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">-1</span>));</span><br><span class="line">        m[<span class="number">0</span>][<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        m[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;size;i++)&#123;</span><br><span class="line">            m[i][<span class="number">0</span>]=m[i<span class="number">-1</span>][<span class="number">1</span>]+nums[i];</span><br><span class="line">            m[i][<span class="number">1</span>]=<span class="built_in">max</span>(m[i<span class="number">-1</span>][<span class="number">1</span>],m[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(m[size<span class="number">-1</span>][<span class="number">1</span>],m[size<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>官方题解简洁好多啊，一个房子有偷和不偷两张可能，偷就是dp[i-2]+nums[i]，即忽略前一个才能偷，不偷就是dp[i-1]，即忽略当前房子。题解还进一步优化，去掉了数组，省下了空间复杂度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> first = nums[<span class="number">0</span>], second = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = second;</span><br><span class="line">            second = <span class="built_in">max</span>(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/house-robber/solutions/263856/da-jia-jie-she-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法题-动态规划&quot;&gt;&lt;a href=&quot;#算法题-动态规划&quot; class=&quot;headerlink&quot; title=&quot;算法题-动态规划&quot;&gt;&lt;/a&gt;算法题-动态规划&lt;/h1&gt;&lt;p&gt;来自&lt;strong&gt;LeetCode 热题 100&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;国庆水几</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://coolling.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>链表5</title>
    <link href="https://coolling.github.io/2024/10/01/%E9%93%BE%E8%A1%A85/"/>
    <id>https://coolling.github.io/2024/10/01/%E9%93%BE%E8%A1%A85/</id>
    <published>2024-10-01T09:37:57.000Z</published>
    <updated>2024-10-01T10:16:04.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法题-链表"><a href="#算法题-链表" class="headerlink" title="算法题-链表"></a>算法题-链表</h1><p>来自<strong>LeetCode 热题 100</strong></p><h2 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a><strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。</strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li></ul><p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>-104 &lt;= Node.val &lt;= 104</code></li><li><code>Node.random</code> 为 <code>null</code> 或指向链表中的节点。</li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>使用hash表将原节点和拷贝节点一一对应，第一遍遍历根据next指针构造链表，同时记下一一对应的关系，第二遍遍历，根据random指针在hash表里寻找对应的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;Node*,Node*&gt; m;</span><br><span class="line">        Node* now=head;</span><br><span class="line">        Node* newhead=<span class="literal">nullptr</span>;</span><br><span class="line">        Node* temp=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(newhead==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                temp=<span class="keyword">new</span> <span class="built_in">Node</span>(now-&gt;val);</span><br><span class="line">                newhead=temp;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp-&gt;next=<span class="keyword">new</span> <span class="built_in">Node</span>(now-&gt;val);</span><br><span class="line">                temp=temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            m[now]=temp;</span><br><span class="line">            now=now-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        now=head;</span><br><span class="line">        temp=newhead;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp-&gt;random=m[now-&gt;random];</span><br><span class="line">            now=now-&gt;next;</span><br><span class="line">            temp=temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>太佩服了，还能这样做，直接省去了额外的空间，第一次遍历，将拷贝节点存在原节点的后面，第二次遍历，确定拷贝节点的random指针的指向，就在原节点指向的random节点的后一个，第三次遍历，将两个链表拆分出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next-&gt;next) &#123;</span><br><span class="line">            Node* nodeNew = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">            nodeNew-&gt;next = node-&gt;next;</span><br><span class="line">            node-&gt;next = nodeNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next-&gt;next) &#123;</span><br><span class="line">            Node* nodeNew = node-&gt;next;</span><br><span class="line">            nodeNew-&gt;random = (node-&gt;random != <span class="literal">nullptr</span>) ? node-&gt;random-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* headNew = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next) &#123;</span><br><span class="line">            Node* nodeNew = node-&gt;next;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">            nodeNew-&gt;next = (nodeNew-&gt;next != <span class="literal">nullptr</span>) ? nodeNew-&gt;next-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/copy-list-with-random-pointer/solutions/889166/fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao-rblsf/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [-1,5,3,4,0]</span><br><span class="line">输出：[-1,0,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>是看了题解才做出来的，一开始想的是使用冒泡排序，但是时间复杂度是O(n2)，nlogn的话，适合归并排序，而自上而下的归并排序适合递归，空间复杂度为O(logn)，即为递归的深度。而自下而上的归并排序，空间复杂度为O（1），因此采用自下而上的归并排序</p><p>1.子链表的长度从1一直翻倍</p><p>2.每次从链表中拿出两个长度为sublength的子链表，最后一次节点数不够可以少于sublength</p><p>3.对两个sublength进行合并</p><p>4.注意每一轮结束要将last-&gt;next设置为空，不然变成环，就会报错heap-use-after-free！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">        ListNode * temp=head;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            temp=temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode * nowhead=head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> sublength=<span class="number">1</span>;sublength&lt;size;sublength&lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;sublength:%d\n&quot;,sublength);</span></span><br><span class="line">            <span class="comment">// printf(&quot;over %d\n&quot;,nowhead-&gt;val);</span></span><br><span class="line">            ListNode * cur=nowhead;</span><br><span class="line">            ListNode * last=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                ListNode * head1=cur;</span><br><span class="line">                <span class="type">int</span> size1=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sublength&amp;&amp;cur!=<span class="literal">nullptr</span>;i++)&#123;</span><br><span class="line">                    cur=cur-&gt;next;</span><br><span class="line">                    size1++;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode * head2=cur;</span><br><span class="line">                <span class="type">int</span> size2=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sublength&amp;&amp;cur!=<span class="literal">nullptr</span>;i++)&#123;</span><br><span class="line">                    cur=cur-&gt;next;</span><br><span class="line">                    size2++;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// printf(&quot;!!\n&quot;);</span></span><br><span class="line">                <span class="keyword">while</span>(size1!=<span class="number">0</span>&amp;&amp;size2!=<span class="number">0</span>)&#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(head1-&gt;val&lt;head2-&gt;val)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(last==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                            nowhead=head1;</span><br><span class="line">                            last=head1;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            last-&gt;next=head1;</span><br><span class="line">                            </span><br><span class="line">                            last=last-&gt;next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        head1=head1-&gt;next;</span><br><span class="line">                        size1--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(last==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                            nowhead=head2;</span><br><span class="line">                            last=head2;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            last-&gt;next=head2;</span><br><span class="line">                            </span><br><span class="line">                            last=last-&gt;next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        head2=head2-&gt;next;</span><br><span class="line">                        size2--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// printf(&quot;%d\n&quot;,last-&gt;val);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(size1!=<span class="number">0</span>)&#123;</span><br><span class="line">                    last-&gt;next=head1;</span><br><span class="line">                    last=last-&gt;next;</span><br><span class="line">                    size1--;</span><br><span class="line">                    head1=head1-&gt;next;</span><br><span class="line">                    <span class="comment">// printf(&quot;%d\n&quot;,last-&gt;val);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(size2!=<span class="number">0</span>)&#123;</span><br><span class="line">                    last-&gt;next=head2;</span><br><span class="line">                    last=last-&gt;next;</span><br><span class="line">                    size2--;</span><br><span class="line">                    head2=head2-&gt;next;</span><br><span class="line">                    <span class="comment">// printf(&quot;%d\n&quot;,last-&gt;val);</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            last-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;sublength:%d over\n&quot;,sublength);</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> nowhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解-1"><a href="#官方题解-1" class="headerlink" title="官方题解"></a>官方题解</h3><p>再把自上而下的递归方法放出来</p><p>几个细节：</p><p>1.快慢指针找中间节点</p><p>2.sortList(ListNode* head, ListNode* tail) 是一个左闭，右开的函数，当head-&gt;next &#x3D;&#x3D; tail，意味着，只有一个节点</p><p>3.head-&gt;next &#x3D; nullptr，为了方便merge，不会遍历到超出范围的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sortList</span>(head, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == tail) &#123;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != tail) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast != tail) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">sortList</span>(head, mid), <span class="built_in">sortList</span>(mid, tail));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="literal">nullptr</span> &amp;&amp; temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/sort-list/solutions/492301/pai-xu-lian-biao-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法题-链表&quot;&gt;&lt;a href=&quot;#算法题-链表&quot; class=&quot;headerlink&quot; title=&quot;算法题-链表&quot;&gt;&lt;/a&gt;算法题-链表&lt;/h1&gt;&lt;p&gt;来自&lt;strong&gt;LeetCode 热题 100&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;随机链表的复制</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="链表" scheme="https://coolling.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="归并排序" scheme="https://coolling.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>技巧1</title>
    <link href="https://coolling.github.io/2024/09/29/%E6%8A%80%E5%B7%A71/"/>
    <id>https://coolling.github.io/2024/09/29/%E6%8A%80%E5%B7%A71/</id>
    <published>2024-09-29T09:06:52.000Z</published>
    <updated>2024-09-29T09:21:56.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法题-技巧"><a href="#算法题-技巧" class="headerlink" title="算法题-技巧"></a>算法题-技巧</h1><p>来自<strong>LeetCode 热题 100</strong></p><p>桑心。。。自己笨笨的。。。</p><p>##只出现一次的数字</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p><strong>示例 1 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,1,2,1,2]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-3 * 104 &lt;= nums[i] &lt;= 3 * 104</code></li><li>除了某个元素只出现一次以外，其余每个元素均出现两次。</li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>使用unordered_set，遇到两个相同的就像消消乐一样消掉了，最后剩下的那个就是答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;n:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">count</span>(n))&#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(n);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">int</span> &amp;n:s)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>原来位运算可以这么用！两个相同的异或一下就消失了，完全不需要额外空间！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/single-number/solutions/242211/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><p><strong>进阶：</strong>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>虽然没有想出来时间复杂度为 O(n)、空间复杂度为 O(1) 的算法，但是用上了结构化结构for(auto &amp;[key,value]:m)，表扬一下自己！</p><p>方法笨笨的，遍历一遍记录次数，再遍历一遍找最多次数的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp; n:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">count</span>(n))&#123;</span><br><span class="line">                m[n]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m[n]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[key,value]:m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(value&gt;nums.<span class="built_in">size</span>()/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解-1"><a href="#官方题解-1" class="headerlink" title="官方题解"></a>官方题解</h3><p>看到题解真的想膜拜大佬的智商。</p><p>想象一个画面，黑色的小兵和五颜六色的小兵碰撞在一起，当碰撞在一起的小兵颜色不同，就一起消失了。由于黑色小兵超过一半，人多势众，即使五颜六色的小兵互相不碰撞，只和黑色小兵碰撞，最后剩下的也只会是黑色小兵。</p><p>想想，感觉和上一题的两个相同就消消乐还有点像勒。</p><p>代码大概就是count个candidate小兵抱团去和人碰撞的过程。遇到相同的抱团继续，遇到不同的，牺牲一个。直到牺牲为0，换下一个candidate主动去碰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> candidate = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == candidate)</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (--count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法题-技巧&quot;&gt;&lt;a href=&quot;#算法题-技巧&quot; class=&quot;headerlink&quot; title=&quot;算法题-技巧&quot;&gt;&lt;/a&gt;算法题-技巧&lt;/h1&gt;&lt;p&gt;来自&lt;strong&gt;LeetCode 热题 100&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;桑心。。。自己笨笨的。。</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="技巧" scheme="https://coolling.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>链表4</title>
    <link href="https://coolling.github.io/2024/09/29/%E9%93%BE%E8%A1%A84/"/>
    <id>https://coolling.github.io/2024/09/29/%E9%93%BE%E8%A1%A84/</id>
    <published>2024-09-29T08:05:36.000Z</published>
    <updated>2024-09-29T08:24:37.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法题-链表"><a href="#算法题-链表" class="headerlink" title="算法题-链表"></a>算法题-链表</h1><p>来自<strong>LeetCode 热题 100</strong></p><p>##两两交换链表中的节点</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这题还是比较简单的，就是每次两个两个遍历，修改他们的指针。</p><p>学到了：最后要记得delete一开始构建的虚假头节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prehead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        prehead-&gt;next=head;</span><br><span class="line">        ListNode* now =prehead;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        <span class="keyword">while</span>(now-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;now-&gt;next-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            next=now-&gt;next;</span><br><span class="line">            now-&gt;next=next-&gt;next;</span><br><span class="line">            next-&gt;next=next-&gt;next-&gt;next;</span><br><span class="line">            now-&gt;next-&gt;next=next;</span><br><span class="line">            now=now-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ans = prehead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> prehead;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>##K 个一组翻转链表</p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[2,1,4,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 3</span><br><span class="line">输出：[3,2,1,4,5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>没有用 <code>O(1)</code> 额外内存空间的算法，昨天做的其他题看到题解有用栈做的，今天就给用上试试。后进先出的特性非常适合做这种逆转链表的题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;ListNode *&gt; s;</span><br><span class="line">        ListNode* prehead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* temp=prehead;</span><br><span class="line">        prehead-&gt;next=head;</span><br><span class="line">        ListNode* now=head;</span><br><span class="line">        <span class="type">int</span> count=k;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(now);</span><br><span class="line">            count--;</span><br><span class="line">            now=now-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    ListNode* nodet=s.<span class="built_in">top</span>();</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    temp-&gt;next=nodet;</span><br><span class="line">                    temp=temp-&gt;next;</span><br><span class="line">                    temp-&gt;next=now;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                count=k;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ans = prehead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> prehead;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>每次遍历k个节点作为一组，提出来作为子链表进行逆转，然后再拼装回去。</p><p>学到了：pair&lt;ListNode*, ListNode*&gt;   </p><p>tie(head, tail) &#x3D; myReverse(head, tail); </p><p><a href="https://lisongmin.github.io/cpp-structed-binding/">https://lisongmin.github.io/cpp-structed-binding/</a> 新语法get</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 翻转一个子链表，并且返回新的头与尾</span></span><br><span class="line">    <span class="function">pair&lt;ListNode*, ListNode*&gt; <span class="title">myReverse</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = tail-&gt;next;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (prev != tail) &#123;</span><br><span class="line">            ListNode* nex = p-&gt;next;</span><br><span class="line">            p-&gt;next = prev;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* hair = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        hair-&gt;next = head;</span><br><span class="line">        ListNode* pre = hair;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode* tail = pre;</span><br><span class="line">            <span class="comment">// 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!tail) &#123;</span><br><span class="line">                    <span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* nex = tail-&gt;next;</span><br><span class="line">            <span class="comment">// 这里是 C++17 的写法，也可以写成</span></span><br><span class="line">            <span class="comment">// pair&lt;ListNode*, ListNode*&gt; result = myReverse(head, tail);</span></span><br><span class="line">            <span class="comment">// head = result.first;</span></span><br><span class="line">            <span class="comment">// tail = result.second;</span></span><br><span class="line">            <span class="built_in">tie</span>(head, tail) = <span class="built_in">myReverse</span>(head, tail);</span><br><span class="line">            <span class="comment">// 把子链表重新接回原链表</span></span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">            tail-&gt;next = nex;</span><br><span class="line">            pre = tail;</span><br><span class="line">            head = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/reverse-nodes-in-k-group/solutions/248591/k-ge-yi-zu-fan-zhuan-lian-biao-by-leetcode-solutio/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法题-链表&quot;&gt;&lt;a href=&quot;#算法题-链表&quot; class=&quot;headerlink&quot; title=&quot;算法题-链表&quot;&gt;&lt;/a&gt;算法题-链表&lt;/h1&gt;&lt;p&gt;来自&lt;strong&gt;LeetCode 热题 100&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##两两交换链表中的节点</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="链表" scheme="https://coolling.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>链表3</title>
    <link href="https://coolling.github.io/2024/09/28/%E9%93%BE%E8%A1%A83/"/>
    <id>https://coolling.github.io/2024/09/28/%E9%93%BE%E8%A1%A83/</id>
    <published>2024-09-28T08:10:05.000Z</published>
    <updated>2024-09-28T08:26:19.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法题-链表"><a href="#算法题-链表" class="headerlink" title="算法题-链表"></a>算法题-链表</h1><p>来自<strong>LeetCode 热题 100</strong></p><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>思路很简单，就是每次比较链表的两个头节点，哪个小就选哪个。</p><p>但是发现题解写的简略好多，仔细观察，他是先自己创建了一个虚假的头指针，可以使代码更简洁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* newlist;</span><br><span class="line">        ListNode* now;</span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val&lt;list2-&gt;val)&#123;</span><br><span class="line">            newlist=now=list1;</span><br><span class="line">            list1=list1-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newlist=now=list2;</span><br><span class="line">            list2=list2-&gt;next;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="literal">nullptr</span>&amp;&amp;list2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val&lt;list2-&gt;val)&#123;</span><br><span class="line">                now-&gt;next=list1;</span><br><span class="line">                list1=list1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                now-&gt;next=list2;</span><br><span class="line">                list2=list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            now=now-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            now-&gt;next=list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            now-&gt;next=list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newlist;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>还有一种递归写法，我觉得也很妙，虽然要消耗栈空间，引入了空间开销</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/merge-two-sorted-lists/solutions/226408/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>大概就是模拟加法的过程，使用一个中间变量temp来记录前一次的进位。</p><p>要记住在while结束之后判断temp是否不为0，因为可能前面有产生进位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *re=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode * now=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span>||l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="type">int</span> a=l1==<span class="literal">nullptr</span>?<span class="number">0</span>:l1-&gt;val;</span><br><span class="line">            <span class="type">int</span> b=l2==<span class="literal">nullptr</span>?<span class="number">0</span>:l2-&gt;val;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(re==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                re=now=<span class="keyword">new</span> <span class="built_in">ListNode</span>((a+b+temp)%<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                now-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>((a+b+temp)%<span class="number">10</span>);</span><br><span class="line">                now=now-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=(a+b+temp)/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="number">0</span>)&#123;</span><br><span class="line">            now-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>没有做到一趟扫描实现。第一次先遍历计算链表长度。然后计算size-n，从head到要删除节点的步数。如果是0，则说明是第一个，直接返回head-&gt;next；如果不是，head前进size-n-1步，到目标节点的前一个修改next指针，进行删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">        ListNode* now=head;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            now=now-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> step=size-n;</span><br><span class="line">        <span class="keyword">if</span>(step&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            step-=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode* t=head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        now=head;</span><br><span class="line">        <span class="keyword">while</span>(step--)&#123;</span><br><span class="line">            now=now-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* t=now-&gt;next;</span><br><span class="line">        now-&gt;next=t-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> t;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解-1"><a href="#官方题解-1" class="headerlink" title="官方题解"></a>官方题解</h3><p>官方题解使用了栈，是真的想不出来www，利用后进先出，就不用遍历两遍了。而且这里同样也是造了个头节点，避免因为要删除节点是第一个增加一些额外的逻辑代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        stack&lt;ListNode*&gt; stk;</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* prev = stk.<span class="built_in">top</span>();</span><br><span class="line">        prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/remove-nth-node-from-end-of-list/solutions/450350/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法题-链表&quot;&gt;&lt;a href=&quot;#算法题-链表&quot; class=&quot;headerlink&quot; title=&quot;算法题-链表&quot;&gt;&lt;/a&gt;算法题-链表&lt;/h1&gt;&lt;p&gt;来自&lt;strong&gt;LeetCode 热题 100&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;合并两个有序链</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="链表" scheme="https://coolling.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>链表2</title>
    <link href="https://coolling.github.io/2024/09/27/%E9%93%BE%E8%A1%A82/"/>
    <id>https://coolling.github.io/2024/09/27/%E9%93%BE%E8%A1%A82/</id>
    <published>2024-09-27T08:09:03.000Z</published>
    <updated>2024-09-27T08:23:38.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法题-链表"><a href="#算法题-链表" class="headerlink" title="算法题-链表"></a>算法题-链表</h1><p>来自<strong>LeetCode 热题 100</strong></p><h2 id="环形链表1"><a href="#环形链表1" class="headerlink" title="环形链表1"></a>环形链表1</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>使用快慢指针，想象龟兔赛跑，如果这是一个环，乌龟最后肯定会被兔子套圈。如果没有环，就到达终点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode * slow=head;</span><br><span class="line">        ListNode * fast=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="环形链表2"><a href="#环形链表2" class="headerlink" title="环形链表2"></a>环形链表2</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>虽然过了，但是没有做到<code>O(1)</code> 空间复杂度。采用的最笨的办法，unordered_set记录走过的节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode *&gt; m;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>&amp;&amp;m.<span class="built_in">count</span>(head)==<span class="number">0</span>)&#123;</span><br><span class="line">            m.<span class="built_in">insert</span>(head);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>wwww好厉害</p><p>1.第一步，使用快慢指针确定是否有环。</p><p>慢指针走了：a+n1*(b+c)+b</p><p>快指针走了：a+n2*(b+c)+b</p><p>快指针走的路程是慢指针的两倍：a+n2*(b+c)+b&#x3D;2 *[ a+n1 *(b+c)+b] 即：(n2-2 *n1-1) * (b+c)+c&#x3D;a</p><p>注：a是没进入环的长度，b是入环点到相遇点的长度，c是环另一半的长度</p><p>2.根据分析，从head到入环点的长度a等于，slow继续走完(n2-2 *n1-1) 圈，再从相遇点到入环点。也就是说，slow和head同时走，会在入环点相遇</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/linked-list-cycle-ii/solutions/441131/huan-xing-lian-biao-ii-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法题-链表&quot;&gt;&lt;a href=&quot;#算法题-链表&quot; class=&quot;headerlink&quot; title=&quot;算法题-链表&quot;&gt;&lt;/a&gt;算法题-链表&lt;/h1&gt;&lt;p&gt;来自&lt;strong&gt;LeetCode 热题 100&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;环形链表1&quot;&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="链表" scheme="https://coolling.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>链表1</title>
    <link href="https://coolling.github.io/2024/09/25/%E9%93%BE%E8%A1%A81/"/>
    <id>https://coolling.github.io/2024/09/25/%E9%93%BE%E8%A1%A81/</id>
    <published>2024-09-25T10:04:53.000Z</published>
    <updated>2024-09-27T08:10:21.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法题-链表"><a href="#算法题-链表" class="headerlink" title="算法题-链表"></a>算法题-链表</h1><p>来自<strong>LeetCode 热题 100</strong></p><p>##相交链表</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>大概的思路就是第一遍遍历的时候记录下来，第二遍遍历的时候遇到的话就是第一个交点</p><p>但是需要额外的空间开销</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode *&gt; m;</span><br><span class="line">        <span class="keyword">while</span>(headA!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            m.<span class="built_in">insert</span>(headA);</span><br><span class="line">            headA=headA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headB!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">count</span>(headB))&#123;</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            &#125;</span><br><span class="line">            headB=headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>我觉得想法特别妙，在到达尾部的时候跳到对方的头部。</p><p>假设A&#x3D;a+c;B&#x3D;b+c。a和b是双方未相交前的长度，c是相交的长度。</p><p>当双方都走了a+c+b时就相遇了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">nullptr</span> ? headB : pA-&gt;next;</span><br><span class="line">            pB = pB == <span class="literal">nullptr</span> ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/intersection-of-two-linked-lists/solutions/811625/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题比较简单，使用3个指针，向前移动，now指向last，last可以理解为已经反转好的节点链表的链表头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode * last=head;</span><br><span class="line">        ListNode * now=head-&gt;next;</span><br><span class="line">        ListNode * next;</span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            next=next-&gt;next;</span><br><span class="line">            now-&gt;next=last;</span><br><span class="line">            last=now;</span><br><span class="line">            now=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解-1"><a href="#官方题解-1" class="headerlink" title="官方题解"></a>官方题解</h3><p>官方题解还给出了一种递归的方法。主要思路就是，目前head-&gt;反转好的链表(head-&gt;next)，只要将head-&gt;next-&gt;next&#x3D;head，就可以得到反转好的链表(head)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/reverse-linked-list/solutions/551596/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>采用了嘴笨的办法：遍历链表将数据全部存下来，再判断是不是回文。占用了额外的空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">getRe</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums ,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[left]==nums[right])&#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">getRe</span>(nums,left+<span class="number">1</span>,right<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nums.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">            size++;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getRe</span>(nums,<span class="number">0</span>,size<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解-2"><a href="#官方题解-2" class="headerlink" title="官方题解"></a>官方题解</h3><p>学到很多：1.使用快慢指针，找到链表的中间；2.使用3个指针将链表的后半段反转；3.比较链表的前半段和后半段；4.再次反转复原链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        ListNode* firstHalfEnd = <span class="built_in">endOfFirstHalf</span>(head);</span><br><span class="line">        ListNode* secondHalfStart = <span class="built_in">reverseList</span>(firstHalfEnd-&gt;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否回文</span></span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        ListNode* p2 = secondHalfStart;</span><br><span class="line">        <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">        firstHalfEnd-&gt;next = <span class="built_in">reverseList</span>(secondHalfStart);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* nextTemp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">endOfFirstHalf</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/palindrome-linked-list/solutions/457059/hui-wen-lian-biao-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法题-链表&quot;&gt;&lt;a href=&quot;#算法题-链表&quot; class=&quot;headerlink&quot; title=&quot;算法题-链表&quot;&gt;&lt;/a&gt;算法题-链表&lt;/h1&gt;&lt;p&gt;来自&lt;strong&gt;LeetCode 热题 100&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##相交链表&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="链表" scheme="https://coolling.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>双指针2</title>
    <link href="https://coolling.github.io/2024/09/23/%E5%8F%8C%E6%8C%87%E9%92%882/"/>
    <id>https://coolling.github.io/2024/09/23/%E5%8F%8C%E6%8C%87%E9%92%882/</id>
    <published>2024-09-23T08:22:54.000Z</published>
    <updated>2024-09-23T08:35:59.784Z</updated>
    
    <content type="html"><![CDATA[<p>#算法题-双指针</p><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这题是看了题解才做出来的。一开始很疑惑，不知道如何和双指针联系上的。</p><p>对vector进行排序后，固定遍历的第一个数，剩下两数之和就确定了，因为已经排序过，当b+c&#x3D;b1+c1时，如果b&gt;b1，则c&lt;c1，这里b和c就可以应用双指针，分别指向两端，当两数之和太大，c–；太小b++。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; re;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> size=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;i:%d\n&quot;,i);</span></span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> r=size<span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> l=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="comment">// printf(&quot;l:%d\n&quot;,l);</span></span><br><span class="line">                <span class="comment">// printf(&quot;r:%d\n&quot;,r);</span></span><br><span class="line">                <span class="keyword">if</span>(l!=i+<span class="number">1</span>&amp;&amp;nums[l]==nums[l<span class="number">-1</span>])&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(r!=size<span class="number">-1</span>&amp;&amp;nums[r]==nums[r+<span class="number">1</span>])&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> t=nums[i]+nums[l]+nums[r];</span><br><span class="line">                <span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">                    re.<span class="built_in">push_back</span>(&#123;nums[i],nums[l],nums[r]&#125;);</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>###题目</p><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题我还是没有想出双指针的做法。某一个位置的储水量等于两边分别最高的高度的最小值-自身的高度。</p><p>每个位置两边最高的计算使用动态规划求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size=height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lh</span><span class="params">(size,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rh</span><span class="params">(size,<span class="number">0</span>)</span></span>;</span><br><span class="line">        lh[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        rh[size<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i<span class="number">-1</span>]&gt;lh[i<span class="number">-1</span>])&#123;</span><br><span class="line">                lh[i]=height[i<span class="number">-1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                lh[i]=lh[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=size<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i+<span class="number">1</span>]&gt;rh[i+<span class="number">1</span>])&#123;</span><br><span class="line">                rh[i]=height[i+<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                rh[i]=rh[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            re+=<span class="built_in">max</span>(<span class="built_in">min</span>(lh[i],rh[i])-height[i],<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>大概是height[left] 与height[right]总有某一方正在占据着目前遍历到的全局最高点。由于对方是目前的全局最高点，必定比自己这边的leftmax&#x2F;rightmax更高，因此矮的那一方目前位置的储水量就可以计算出来了。</p><p>比我自己方法的好处是减少了空间占用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax, height[left]);</span><br><span class="line">            rightMax = <span class="built_in">max</span>(rightMax, height[right]);</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                ans += leftMax - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += rightMax - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#算法题-双指针&lt;/p&gt;
&lt;h2 id=&quot;三数之和&quot;&gt;&lt;a href=&quot;#三数之和&quot; class=&quot;headerlink&quot; title=&quot;三数之和&quot;&gt;&lt;/a&gt;三数之和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="双指针" scheme="https://coolling.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="https://coolling.github.io/2024/09/21/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>https://coolling.github.io/2024/09/21/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2024-09-21T10:57:34.000Z</published>
    <updated>2024-09-21T11:13:46.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong>的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我感觉滑动窗口貌似和双指针有点像。枚举从每一个位置开始的最长不重复子串，而后一个位置可以利用前一个位置的结果：即将前一个位置的字符删掉，接着往下查探。</p><p>学到：unordered_set</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=<span class="number">-1</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; occ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;size;l++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l!=<span class="number">0</span>)&#123;</span><br><span class="line">                occ.<span class="built_in">erase</span>(s[l<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r+<span class="number">1</span>&lt;size&amp;&amp;!occ.<span class="built_in">count</span>(s[r+<span class="number">1</span>]))&#123;</span><br><span class="line">                occ.<span class="built_in">insert</span>(s[r+<span class="number">1</span>]);</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(re&lt;r-l+<span class="number">1</span>)&#123;</span><br><span class="line">                re=r-l+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 </p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这道题还是挺直观的，大概直觉就是在每个位置取s2个字母看看是不是和p一样。区别在于如何更快地比较。</p><p>为了忽略顺序，将字符存在vector<int>数组，每次比较数组是否相同。而窗口的滑动对应数组的删改也很容易，将前一个字符对应的位置–，后一个字符对应的位置++</p><p>学到：本来还想用上一题学到的unordered_set，但是unordered_set比较的时间复杂度是O(n2)。虽然抛开时间复杂度，我一开始没意识到，使用unordered_set进行解题也没通过…..菜鸡爆哭.jpg 不知道unordered_set的比较是不是有什么坑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">        <span class="type">int</span> s1=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> s2=p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(s1&lt;s2)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ss</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ps</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s2;i++)&#123;</span><br><span class="line">            ss[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            ps[p[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ss==ps)&#123;</span><br><span class="line">            re.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1-s2;i++)&#123;</span><br><span class="line">            ss[s[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            ss[s[i+s2]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(ss==ps)&#123;</span><br><span class="line">                </span><br><span class="line">                re.<span class="built_in">emplace_back</span>(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;滑动窗口&quot;&gt;&lt;a href=&quot;#滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口&quot;&gt;&lt;/a&gt;滑动窗口&lt;/h1&gt;&lt;h2 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="滑动窗口" scheme="https://coolling.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>双指针1</title>
    <link href="https://coolling.github.io/2024/09/16/%E5%8F%8C%E6%8C%87%E9%92%881/"/>
    <id>https://coolling.github.io/2024/09/16/%E5%8F%8C%E6%8C%87%E9%92%881/</id>
    <published>2024-09-16T08:59:44.000Z</published>
    <updated>2024-09-16T09:11:56.747Z</updated>
    
    <content type="html"><![CDATA[<p>#算法题-双指针</p><p>来自<strong>LeetCode 热题 100</strong></p><p>##移动零</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这个题我的思路不是双指针，大概的思路是：遍历的时候记录前面有几个0，就意味着这个数字应该往前再移动几位。最后再将末尾的部分置为0.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i-j]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=size-j;i&lt;size;i++)&#123;</span><br><span class="line">            nums[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>官方题解是设了两个指针，在l之前的都是不为0，r之后的是未处理的，l和r之间的都为0。这样每次r遇到非0，就和l交换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/move-zeroes/solutions/489622/yi-dong-ling-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>##盛最多水的容器</p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>好像是一道很经典的双指针题目，两个指针一开始分别指向两端，这个时候应该先移动哪个指针呢？因为木桶短板原理，这个时候容积由短的那一端决定。如果想提升容积，只能移动较低的那一端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size=height.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=size<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">            <span class="type">int</span> t=<span class="built_in">min</span>(height[l],height[r]);</span><br><span class="line">            <span class="keyword">if</span>((r-l)*t&gt;re)&#123;</span><br><span class="line">                re=(r-l)*t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(height[l]&gt;height[r])&#123;</span><br><span class="line">                r=r<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l=l+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#算法题-双指针&lt;/p&gt;
&lt;p&gt;来自&lt;strong&gt;LeetCode 热题 100&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##移动零&lt;/p&gt;
&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="双指针" scheme="https://coolling.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>哈希</title>
    <link href="https://coolling.github.io/2024/09/08/%E5%93%88%E5%B8%8C/"/>
    <id>https://coolling.github.io/2024/09/08/%E5%93%88%E5%B8%8C/</id>
    <published>2024-09-08T07:50:23.000Z</published>
    <updated>2024-09-08T08:20:23.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法题-哈希"><a href="#算法题-哈希" class="headerlink" title="算法题-哈希"></a>算法题-哈希</h1><p>来自<strong>LeetCode 热题 100</strong></p><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将值全存到hash表中，然后枚举每个数，判断target-num在不在hash表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="type">int</span> size=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            m[nums[i]]=i;</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it=m.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(it!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">             </span><br><span class="line">                <span class="keyword">if</span>(i!=it-&gt;second)&#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    result.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p><strong>应该用unordered_map的，它内部是hash表，操作的复杂度是O(1)，而map底层是红黑树，操作的复杂度是O(lgn)</strong></p><p>代码也可以写得更简洁一些，边找边存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/two-sum/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>在查找和存之前，先对字符串进行排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string,vector&lt;string&gt;&gt; m;</span><br><span class="line">        <span class="type">int</span> s = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">            string t = strs[i];</span><br><span class="line">            <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> it=m.<span class="built_in">find</span>(t);</span><br><span class="line">            <span class="keyword">if</span>(it!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">// printf(&quot;%s\n&quot;,t.c_str());</span></span><br><span class="line">                it-&gt;second.<span class="built_in">emplace_back</span>(strs[i]);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m[t]=&#123;strs[i]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> iterator = m.<span class="built_in">begin</span>();</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span>(iterator!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">            result.<span class="built_in">emplace_back</span>(iterator-&gt;second);</span><br><span class="line">            iterator++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h3><p>一开始用的是push_back，它和emplace_back的区别是，push_back直接将对象复制到容器，而emplace_back是传递参数，调用对象的构造函数创建对象，后者减少了内存之间的移动</p><p>尝试用 for (string&amp; str: strs)这个写法简洁些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; str: strs) &#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            mp[key].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>在我感觉，这个题有一点像是图遍历，有一点像是找到所有子图，返回最大的子图的节点数。看似有两层循环，但是每个节点只被访问一次，实际上复杂度是O(n)。</p><p>其中hash表的存在，在里面的作用是：快速判断是否有边；判断是否被访问过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            m[num]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(m[num]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> num1=num;</span><br><span class="line">                <span class="keyword">while</span>(m.<span class="built_in">find</span>(num1)!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    t++;</span><br><span class="line">                    m.<span class="built_in">find</span>(num1)-&gt;second=<span class="number">1</span>;</span><br><span class="line">                    num1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> num2=num<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(m.<span class="built_in">find</span>(num2)!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    t++;</span><br><span class="line">                    m.<span class="built_in">find</span>(num2)-&gt;second=<span class="number">1</span>;</span><br><span class="line">                    num2--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t&gt;re)&#123;</span><br><span class="line">                    re=t;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不足-2"><a href="#不足-2" class="headerlink" title="不足"></a>不足</h3><p>和官方题解虽然写法不同，但是其实是一个意思。</p><p>for (const int&amp; num : num_set)。这种写法避免了对变量的修改（const），也避免了不必要的拷贝（&amp;）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : nums) &#123;</span><br><span class="line">            num_set.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> longestStreak = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : num_set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!num_set.<span class="built_in">count</span>(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> currentNum = num;</span><br><span class="line">                <span class="type">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (num_set.<span class="built_in">count</span>(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentStreak += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                longestStreak = <span class="built_in">max</span>(longestStreak, currentStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longestStreak;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/longest-consecutive-sequence/solutions/276931/zui-chang-lian-xu-xu-lie-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法题-哈希&quot;&gt;&lt;a href=&quot;#算法题-哈希&quot; class=&quot;headerlink&quot; title=&quot;算法题-哈希&quot;&gt;&lt;/a&gt;算法题-哈希&lt;/h1&gt;&lt;p&gt;来自&lt;strong&gt;LeetCode 热题 100&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;两数之和&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="哈希" scheme="https://coolling.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://coolling.github.io/2024/09/05/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://coolling.github.io/2024/09/05/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2024-09-05T08:01:37.000Z</published>
    <updated>2024-09-05T08:15:28.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><strong>管道类似于文件重定向，可以将前一个命令的stdout重定向到下一个命令的stdin。</strong></p><p>要点</p><blockquote><p>管道命令仅处理stdout，会忽略stderr。<br>管道右边的命令必须能接受stdin。<br>多个管道命令可以串联。</p></blockquote><p>与文件重定向的区别</p><blockquote><p>文件重定向左边为命令，右边为文件。<br>管道左右两边均为命令，左边有stdout，右边有stdin。</p></blockquote><p>举例</p><blockquote><p>find . -name ‘*.py’ | xargs cat | wc -l</p></blockquote><h2 id="系统状况"><a href="#系统状况" class="headerlink" title="系统状况"></a>系统状况</h2><ol><li><p>top：查看所有进程的信息（Linux的任务管理器）</p><blockquote><p>打开后，输入M：按使用内存排序</p><p>打开后，输入P：按使用CPU排序</p><p>打开后，输入q：退出</p></blockquote></li><li><p>df -h：查看硬盘使用情况</p></li><li><p>free -h：查看内存使用情况</p></li><li><p>du -sh：查看当前目录占用的硬盘空间</p></li><li><p>ps aux：查看所有进程</p></li><li><p>kill -9 pid：杀死编号为pid的进程</p><blockquote><p>传递某个具体的信号：kill -s SIGTERM pid</p></blockquote></li><li><p>netstat -nt：查看所有网络连接</p></li><li><p>w：列出当前登陆的用户</p></li><li><p>ping <a href="http://www.baidu.com：检查是否连网">www.baidu.com：检查是否连网</a></p></li></ol><h2 id="常用文件管理命令"><a href="#常用文件管理命令" class="headerlink" title="常用文件管理命令"></a>常用文件管理命令</h2><ol><li><p>ctrl c: 取消命令，并且换行</p></li><li><p>ctrl u: 清空本行命令</p></li><li><p>tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p></li><li><p>ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p></li><li><p>pwd: 显示当前路径</p></li><li><p>cd XXX: 进入XXX目录下, cd .. 返回上层目录</p></li><li><p>cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如..&#x2F;dir_c&#x2F;a.txt，表示上层目录下的dir_c文件夹下的文件a.txt</p></li><li><p>mkdir XXX: 创建目录XXX</p></li><li><p>rm XXX: 删除普通文件;  rm XXX -r: 删除文件夹</p></li><li><p>mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令</p></li><li><p>touch XXX: 创建一个文件</p></li><li><p>cat XXX: 展示文件XXX中的内容</p></li></ol><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>chmod：修改文件权限</p><blockquote><p>chmod +x xxx：给xxx添加可执行权限<br>chmod -x xxx：去掉xxx的可执行权限<br>chmod 777 xxx：将xxx的权限改成777<br>chmod 777 xxx -R：递归修改整个文件夹的权限</p></blockquote><h2 id="文件检索"><a href="#文件检索" class="headerlink" title="文件检索"></a>文件检索</h2><ol><li><p>find &#x2F;path&#x2F;to&#x2F;directory&#x2F; -name ‘<em>.py’：搜索某个文件路径下的所有</em>.py文件</p></li><li><p>grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行；否则忽略该行。</p></li><li><p>wc：统计行数、单词数、字节数</p><p>既可以从stdin中直接读入内容；也可以在命令行参数中传入文件名列表；</p><blockquote><p>wc -l：统计行数</p><p>wc -w：统计单词数</p><p>wc -c：统计字节数</p></blockquote></li><li><p>tree：展示当前目录的文件结构</p><blockquote><p>tree &#x2F;path&#x2F;to&#x2F;directory&#x2F;：展示某个目录的文件结构</p><p>tree -a：展示隐藏文件</p></blockquote></li><li><p>ag xxx：搜索当前目录下的所有文件，检索xxx字符串</p></li><li><p>cut：分割一行内容</p><p>从stdin中读入多行数据</p><blockquote><p>echo $PATH | cut -d ‘:’ -f 3,5：输出PATH用:分割后第3、5列数据</p><p>echo $PATH | cut -d ‘:’ -f 3-5：输出PATH用:分割后第3-5列数据</p><p>echo $PATH | cut -c 3,5：输出PATH的第3、5个字符</p><p>echo $PATH | cut -c 3-5：输出PATH的第3-5个字符</p></blockquote></li><li><p>sort：将每行内容按字典序排序</p><p>可以从stdin中读取多行数据</p><p>可以从命令行参数中读取文件名列表</p></li><li><p>xargs：将stdin中的数据用空格或回车分割成命令行参数</p><blockquote><p>find . -name ‘*.py’ | xargs cat | wc -l：统计当前目录下所有python文件的总行数</p></blockquote></li></ol><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><ol><li><p>more：浏览文件内容</p><blockquote><p>回车：下一行</p><p>空格：下一页</p><p>b：上一页</p><p>q：退出</p></blockquote></li><li><p>less：与more类似，功能更全</p><blockquote><p>回车：下一行</p><p>y：上一行</p><p>Page Down：下一页</p><p>Page Up：上一页</p><p>q：退出</p></blockquote></li><li><p>head -3 xxx：展示xxx的前3行内容</p><p>同时支持从stdin读入内容</p></li><li><p>tail -3 xxx：展示xxx末尾3行内容</p><p>同时支持从stdin读入内容</p></li></ol><h2 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h2><ol><li>history：展示当前用户的历史操作。内容存放在~&#x2F;.bash_history中</li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><p>md5sum：计算md5哈希值</p><p>可以从stdin读入内容</p><p>也可以在命令行参数中传入文件名列表；</p></li><li><p>time command：统计command命令的执行时间</p></li><li><p>ipython3：交互式python3环境。可以当做计算器，或者批量管理文件。</p><blockquote><p>! echo “Hello World”：!表示执行shell脚本</p></blockquote></li><li><p>watch -n 0.1 command：每0.1秒执行一次command命令</p></li><li><p>tar：压缩文件</p><p>tar -zcvf xxx.tar.gz &#x2F;path&#x2F;to&#x2F;file&#x2F;*：压缩</p><p>tar -zxvf xxx.tar.gz：解压缩</p></li><li><p>diff xxx yyy：查找文件xxx与yyy的不同点</p></li></ol><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><ol><li>sudo command：以root身份执行command命令</li><li>apt-get install xxx：安装软件</li><li>pip install xxx –user –upgrade：安装python包</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux常用命令&quot;&gt;&lt;a href=&quot;#Linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令&quot;&gt;&lt;/a&gt;Linux常用命令&lt;/h1&gt;&lt;h2 id=&quot;管道&quot;&gt;&lt;a href=&quot;#管道&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="linux基础" scheme="https://coolling.github.io/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux常用命令" scheme="https://coolling.github.io/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="https://coolling.github.io/2024/08/31/git/"/>
    <id>https://coolling.github.io/2024/08/31/git/</id>
    <published>2024-08-31T10:44:39.000Z</published>
    <updated>2024-08-31T10:46:46.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h1><h2 id="git基本概念"><a href="#git基本概念" class="headerlink" title="git基本概念"></a>git基本概念</h2><ul><li>工作区：仓库的目录。工作区是独立于各个分支的。</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中每个节点代表一个代码版本。</li></ul><h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><ol><li>git config –global user.name xxx：设置全局用户名，信息记录在~&#x2F;.gitconfig文件中</li><li>git config –global user.email <a href="mailto:&#120;&#120;&#x78;&#64;&#x78;&#x78;&#120;&#x2e;&#x63;&#x6f;&#x6d;">&#120;&#120;&#x78;&#64;&#x78;&#x78;&#120;&#x2e;&#x63;&#x6f;&#x6d;</a>：设置全局邮箱地址，信息记录在~&#x2F;.gitconfig文件中</li><li>git init：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中</li><li>git add XX：将XX文件添加到暂存区</li><li>git add .：将所有待加入暂存区的文件加入暂存区</li><li>git rm –cached XX：将文件从仓库索引目录中删掉</li><li>git commit -m “给自己看的备注信息”：将暂存区的内容提交到当前分支</li><li>git status：查看仓库状态</li><li>git diff XX：查看XX文件相对于暂存区修改了哪些内容</li><li>git log：查看当前分支的所有版本</li><li>git reflog：查看HEAD指针的移动历史（包括被回滚的版本）</li><li>git reset –hard HEAD^ 或 git reset –hard HEAD~：将代码库回滚到上一个版本</li><li>git reset –hard HEAD^^：往上回滚两次，以此类推</li><li>git reset –hard HEAD~100：往上回滚100个版本</li><li>git reset –hard 版本号：回滚到某一特定版本</li><li>git checkout — XX或git restore XX：将XX文件尚未加入暂存区的修改全部撤销</li><li>git remote add origin <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#x2e;&#x61;&#x63;&#119;&#x69;&#x6e;&#103;&#x2e;&#x63;&#111;&#x6d;">&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#x2e;&#x61;&#x63;&#119;&#x69;&#x6e;&#103;&#x2e;&#x63;&#111;&#x6d;</a>:xxx&#x2F;XXX.git：将本地仓库关联到远程仓库</li><li>git push -u (第一次需要-u以后不需要)：将当前分支推送到远程仓库</li><li>git push origin branch_name：将本地的某个分支推送到远程仓库</li><li>git clone <a href="mailto:&#103;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#x2e;&#97;&#x63;&#x77;&#105;&#x6e;&#103;&#x2e;&#99;&#111;&#x6d;">&#103;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#x2e;&#97;&#x63;&#x77;&#105;&#x6e;&#103;&#x2e;&#99;&#111;&#x6d;</a>:xxx&#x2F;XXX.git：将远程仓库XXX下载到当前目录下</li><li>git checkout -b branch_name：创建并切换到branch_name这个分支</li><li>git branch：查看所有分支和当前所处分支</li><li>git checkout branch_name：切换到branch_name这个分支</li><li>git merge branch_name：将分支branch_name合并到当前分支上</li><li>git branch -d branch_name：删除本地仓库的branch_name分支</li><li>git branch branch_name：创建新分支</li><li>git push –set-upstream origin branch_name：设置本地的branch_name分支对应远程仓库的branch_name分支</li><li>git push -d origin branch_name：删除远程仓库的branch_name分支</li><li>git pull：将远程仓库的当前分支与本地仓库的当前分支合并</li><li>git pull origin branch_name：将远程仓库的branch_name分支与本地仓库的当前分支合并</li><li>git branch –set-upstream-to&#x3D;origin&#x2F;branch_name1 branch_name2：将远程的branch_name1分支与本地的branch_name2分支对应</li><li>git checkout -t origin&#x2F;branch_name 将远程的branch_name分支拉取到本地</li><li>git stash：将工作区和暂存区中尚未提交的修改存入栈中</li><li>git stash apply：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</li><li>git stash drop：删除栈顶存储的修改</li><li>git stash pop：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</li><li>git stash list：查看栈中所有元素</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git使用&quot;&gt;&lt;a href=&quot;#git使用&quot; class=&quot;headerlink&quot; title=&quot;git使用&quot;&gt;&lt;/a&gt;git使用&lt;/h1&gt;&lt;h2 id=&quot;git基本概念&quot;&gt;&lt;a href=&quot;#git基本概念&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="linux基础" scheme="https://coolling.github.io/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="git" scheme="https://coolling.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>ssh常用命令</title>
    <link href="https://coolling.github.io/2024/08/28/ssh%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://coolling.github.io/2024/08/28/ssh%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2024-08-28T14:14:34.000Z</published>
    <updated>2024-08-28T14:40:26.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSH基本用法"><a href="#SSH基本用法" class="headerlink" title="SSH基本用法"></a>SSH基本用法</h1><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><h3 id="远程登录服务器"><a href="#远程登录服务器" class="headerlink" title="远程登录服务器"></a>远程登录服务器</h3><p><strong>1.ssh user@hostname</strong></p><blockquote><p>user: 用户名<br>hostname: IP地址或域名</p></blockquote><p><strong>2.第一次登录时会提示：</strong></p><blockquote><p>The authenticity of host ‘123.57.47.211 (123.57.47.211)’ can’t be established.<br>ECDSA key fingerprint is SHA256:iy237yysfCe013&#x2F;l+kpDGfEG9xxHxm0dnxnAbJTPpG8.<br>Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])?</p></blockquote><p>输入yes，然后回车即可。<br>这样会将该服务器的信息记录在~&#x2F;.ssh&#x2F;known_hosts文件中。</p><p>然后输入密码即可登录到远程服务器中。</p><p><strong>3.默认登录端口号为22</strong>。如果想登录某一特定端口：</p><blockquote><p>ssh user@hostname -p 22</p></blockquote><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><strong>1.创建文件 ~&#x2F;.ssh&#x2F;config。</strong></p><p><strong>2.然后在文件中输入：</strong></p><blockquote><p>Host myserver1<br>    HostName IP地址或域名<br>    User 用户名</p><p>Host myserver2<br>    HostName IP地址或域名<br>    User 用户名</p></blockquote><p><strong>3.之后再使用服务器时，可以直接使用别名myserver1、myserver2。</strong></p><h3 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h3><p><strong>1.创建密钥：</strong></p><blockquote><p>ssh-keygen</p></blockquote><p>然后一直回车即可。</p><p>执行结束后，~&#x2F;.ssh&#x2F;目录下会多两个文件：</p><blockquote><p>id_rsa：私钥<br>id_rsa.pub：公钥</p></blockquote><p><strong>2.之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。</strong></p><p>例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的~&#x2F;.ssh&#x2F;authorized_keys文件里即可。</p><p><strong>3.也可以使用如下命令一键添加公钥：</strong></p><blockquote><p>ssh-copy-id myserver</p></blockquote><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>命令格式：</p><blockquote><p>ssh user@hostname command</p></blockquote><p>例如：</p><blockquote><p>ssh user@hostname ls -a</p></blockquote><h2 id="SCP"><a href="#SCP" class="headerlink" title="SCP"></a>SCP</h2><p><strong>1.将source路径下的文件复制到destination中：</strong></p><blockquote><p>scp source destination</p></blockquote><p><strong>2.一次复制多个文件：</strong></p><blockquote><p>scp source1 source2 destination</p></blockquote><p><strong>3.复制文件夹：</strong></p><blockquote><p>scp -r ~&#x2F;tmp myserver:&#x2F;home&#x2F;acs&#x2F;<br>将本地家目录中的tmp文件夹复制到myserver服务器中的&#x2F;home&#x2F;acs&#x2F;目录下。</p></blockquote><blockquote><p>scp -r <del>&#x2F;tmp myserver:homework&#x2F;<br>将本地家目录中的tmp文件夹复制到myserver服务器中的</del>&#x2F;homework&#x2F;目录下。</p></blockquote><blockquote><p>scp -r myserver:homework .<br>将myserver服务器中的~&#x2F;homework&#x2F;文件夹复制到本地的当前路径下。</p></blockquote><p><strong>4.指定服务器的端口号：</strong></p><blockquote><p>scp -P 22 source1 source2 destination</p></blockquote><p>注意： scp的-r -P等参数尽量加在source和destination之前。</p><p><strong>5.使用scp配置其他服务器的vim和tmux</strong></p><blockquote><p>scp ~&#x2F;.vimrc ~&#x2F;.tmux.conf myserver:</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSH基本用法&quot;&gt;&lt;a href=&quot;#SSH基本用法&quot; class=&quot;headerlink&quot; title=&quot;SSH基本用法&quot;&gt;&lt;/a&gt;SSH基本用法&lt;/h1&gt;&lt;h2 id=&quot;SSH&quot;&gt;&lt;a href=&quot;#SSH&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="linux基础" scheme="https://coolling.github.io/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="ssh" scheme="https://coolling.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>vim使用</title>
    <link href="https://coolling.github.io/2024/08/14/vim%E4%BD%BF%E7%94%A8/"/>
    <id>https://coolling.github.io/2024/08/14/vim%E4%BD%BF%E7%94%A8/</id>
    <published>2024-08-14T14:57:31.000Z</published>
    <updated>2024-08-14T14:59:49.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim使用"><a href="#vim使用" class="headerlink" title="vim使用"></a>vim使用</h1><pre><code>        功能：        (1) 命令行模式下的文本编辑器。        (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。        (3) 使用方式：vim filename            如果已有该文件，则打开它。            如果没有该文件，则打开个一个新的文件，并命名为filename    模式：        (1) 一般命令模式            默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。        (2) 编辑模式            在一般命令模式里按下i，会进入编辑模式。            按下ESC会退出编辑模式，返回到一般命令模式。        (3) 命令行模式            在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。            可以查找、替换、保存、退出、配置编辑器等。    操作：        (1) i：进入辑模式        (2) ESC：进入一般命令模式        (3) h 或 左箭头键：光标向左移动一个字符        (4) j 或 向下箭头：光标向下移动一个字符        (5) k 或 向上箭头：光标向上移动一个字符        (6) l 或 向右箭头：光标向右移动一个字符        (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符        (8) 0 或 功能键[Home]：光标移动到本行开头        (9) $ 或 功能键[End]：光标移动到本行末尾        (10) G：光标移动到最后一行        (11) :n 或 nG：n为数字，光标移动到第n行        (12) gg：光标移动到第一行，相当于1G        (13) n&lt;Enter&gt;：n为数字，光标向下移动n行        (14) /word：向光标之下寻找第一个值为word的字符串。        (15) ?word：向光标之上寻找第一个值为word的字符串。        (16) n：重复前一个查找操作        (17) N：反向重复前一个查找操作        (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2        (19) :1,$s/word1/word2/g：将全文的word1替换为word2        (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。        (21) v：选中文本        (22) d：删除选中的文本        (23) dd: 删除当前行        (24) y：复制选中的文本        (25) yy: 复制当前行        (26) p: 将复制的数据在光标的下一行/下一个位置粘贴        (27) u：撤销        (28) Ctrl + r：取消撤销        (29) 大于号 &gt;：将选中的文本整体向右缩进一次        (30) 小于号 &lt;：将选中的文本整体向左缩进一次        (31) :w 保存        (32) :w! 强制保存        (33) :q 退出        (34) :q! 强制退出        (35) :wq 保存并退出        (36) :set paste 设置成粘贴模式，取消代码自动缩进        (37) :set nopaste 取消粘贴模式，开启代码自动缩进        (38) :set nu 显示行号        (39) :set nonu 隐藏行号        (40) gg=G：将全文代码格式化        (41) :noh 关闭查找关键词高亮        (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令    异常处理：        每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。        如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：            (1) 找到正在打开该文件的程序，并退出            (2) 直接删掉该swp文件即可</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vim使用&quot;&gt;&lt;a href=&quot;#vim使用&quot; class=&quot;headerlink&quot; title=&quot;vim使用&quot;&gt;&lt;/a&gt;vim使用&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;        功能：
        (1) 命令行模式下的文本编辑器。
        (2) </summary>
      
    
    
    
    <category term="linux基础" scheme="https://coolling.github.io/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="vim" scheme="https://coolling.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>tmux使用</title>
    <link href="https://coolling.github.io/2024/08/14/tmux%E4%BD%BF%E7%94%A8/"/>
    <id>https://coolling.github.io/2024/08/14/tmux%E4%BD%BF%E7%94%A8/</id>
    <published>2024-08-14T14:47:23.000Z</published>
    <updated>2024-08-14T14:49:48.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tmux使用"><a href="#tmux使用" class="headerlink" title="tmux使用"></a>tmux使用</h1><pre><code>功能：    (1) 分屏。    (2) 允许断开Terminal连接后，继续运行进程。结构：    一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。    实例：        tmux:            session 0:                window 0:                    pane 0                    pane 1                    pane 2                    ...                window 1                window 2                ...            session 1            session 2            ...操作：    (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。    (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。    (3) 按下Ctrl + a后手指松开，然后按&quot;：将当前pane上下平分成两个pane。    (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。    (5) 鼠标点击可以选pane。    (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。    (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。    (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。    (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。    (10) 按下ctrl + a后手指松开，然后按d：挂起当前session。    (11) tmux a：打开之前挂起的session。    (12) 按下ctrl + a后手指松开，然后按s：选择其它session。        方向键 —— 上：选择上一项 session/window/pane        方向键 —— 下：选择下一项 session/window/pane        方向键 —— 右：展开当前项 session/window        方向键 —— 左：闭合当前项 session/window    (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。    (14) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。    (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。    (16) 鼠标滚轮：翻阅当前pane内的内容。    (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）    (18) tmux中复制/粘贴文本的通用方式：        (1) 按下Ctrl + a后松开手指，然后按[        (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板        (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tmux使用&quot;&gt;&lt;a href=&quot;#tmux使用&quot; class=&quot;headerlink&quot; title=&quot;tmux使用&quot;&gt;&lt;/a&gt;tmux使用&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;功能：
    (1) 分屏。
    (2) 允许断开Terminal连接后，继续运行进程</summary>
      
    
    
    
    <category term="linux基础" scheme="https://coolling.github.io/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="tmux" scheme="https://coolling.github.io/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>NSDI24-Parcae</title>
    <link href="https://coolling.github.io/2024/05/19/NSDI24-Parcae/"/>
    <id>https://coolling.github.io/2024/05/19/NSDI24-Parcae/</id>
    <published>2024-05-19T14:13:03.000Z</published>
    <updated>2024-05-19T14:25:56.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Parcae-Proactive-Liveput-Optimized-DNN-Training-on-Preemptible-Instances"><a href="#Parcae-Proactive-Liveput-Optimized-DNN-Training-on-Preemptible-Instances" class="headerlink" title="Parcae: Proactive, Liveput-Optimized DNN Training on Preemptible Instances"></a>Parcae: Proactive, Liveput-Optimized DNN Training on Preemptible Instances</h1><p>nsdi24</p><p>针对抢占式实例进行主动、Liveput 优化的 DNN 训练</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>dnn越来越大–》训练越来越贵–》使用spot可抢占实例（低90%的价格）–》但是随时会被抢占怎么办</p><p><strong>以前的方法</strong></p><p>1.检查点：<strong>抢占频率</strong>高，检查点不适合</p><p>2.反应式，如bamboo 性能和可扩展性有限。很难通过管道气泡完全隐藏<strong>冗余计算的开销</strong>，特别是大模型。并且<strong>增加内存消耗</strong>，bamboo通过增加流水线深度来解决，但是这样会导致计算效率降低</p><h2 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h2><p><strong>parcae</strong>：主动式，在抢占之前预测资源变化，主动调整并行度</p><p><strong>新指标</strong>：<strong>liveput</strong>，测量dnn作业在各种抢占场景下的预期训练吞吐量。</p><p>（同时考虑了并行配置的吞吐量及其在抢占情况下的鲁棒性）</p><p><strong>parcae的关键见解：并行dnn训练的不同策略在抢占情况下表现出不同的鲁棒性。</strong></p><p>更长的流水线可以获得更高的吞吐量但更容易遭到抢占</p><p><img src="/../images/Parcae/parcae1.png" alt="img"></p><p><strong>如何预测？如何处理抢占？如何选择最佳并行配置？</strong></p><p>1.实例的抢占是不可知的，parcase使用两级方法来粗粒度地预测所有实例的可用性。</p><p>a.使用一个可用性预测器：输入实例的抢占和分配历史，预测近期可用实例的数量</p><p>b.蒙特卡洛抢占采样器使用预测的实例可用性对抢占进行采样</p><p>2.parcae使用轻量级实时迁移机制来处理抢占允许dnn训练在丢失实例的情况下继续进行</p><p>在每次迭代使用相同数量的样本更新模型参数，并机会性地重新排序样本来避免冗余计算或重新启动训练</p><p>3.liveput优化器将最大化liveput的问题表述为优化问题，使用新颖的动态规划算法来探索并行配置的搜索空间。</p><p><img src="/../images/Parcae/parcae2.png" alt="img"></p><h2 id="liveput指标"><a href="#liveput指标" class="headerlink" title="liveput指标"></a>liveput指标</h2><p>训练作业的liveup是其在所有可能的抢占场景下的期望吞吐量</p><p>D：数据并行数量</p><p>P：流水线阶段数目</p><p>V：抢占场景的概率分布</p><p><img src="/../images/Parcae/parcae3.png" alt="img"></p><p>V是一个D*P维的0 1向量，vk&#x3D;1代表第k个实例被抢占。其中的吞吐量计算是指发生v抢占后的新并行配置的吞吐量</p><p><strong>liveput指标和吞吐量指标的差异</strong></p><p>优势：它考虑了并行配置的性能在不同抢占场景下的变化</p><p><img src="/../images/Parcae/parcae4.png" alt="img"></p><p>吞吐量不考虑抢占的情况，因此任何场景下上图第一个都优于第二个。</p><p>较长的管道更容易受到抢占，因为单个抢占将使小批次内的这个管道失效，较短的管道在频繁的抢占下表现出更好的弹性和复原力。</p><h2 id="Parcae概述"><a href="#Parcae概述" class="headerlink" title="Parcae概述"></a>Parcae概述</h2><p><img src="/../images/Parcae/parcae5.png" alt="img"></p><p>1.使用两级方法粗粒度地预测所有实例的可用性</p><p>预测未来可用实例的数量，使用预测的可用性对抢占和分配进行采样</p><p>2.将预测的实例可用性作为输入，发现最大化liveput的并行配置</p><p>3.parcae使用3个实时迁移策略，减少开销</p><h2 id="可用性预测器"><a href="#可用性预测器" class="headerlink" title="可用性预测器"></a>可用性预测器</h2><p>1.单个实例的可用性不可预测</p><p>2.统计可用性预测</p><p>唯一可见且可靠的信息是当前用户提交的训练作业的过去抢占&#x2F;分配记录。</p><p><strong>预测的是可获得的实例数量</strong></p><p>使用过去H个时刻的可用实例数目作为输入，预测未来的可用实例数目</p><p>选择一个轻量级的自回归积分移动平均（ARIMA）算法进行预测。</p><p>从预测的可用实例数目，进一步推导出抢占或者分配数目（云不会同时分配和抢占同一个任务）</p><h2 id="实时迁移"><a href="#实时迁移" class="headerlink" title="实时迁移"></a>实时迁移</h2><p>给定抢占预测结果，Parcae可以提前安排有效的调整</p><p>1.实例抢占的影响很大程度取决于实例在数据并行和管道并行中的位置，但是在前一步的预测结果中并没有这些信息。</p><p>parcae使用概率模型来推理抢占事件到实际实例的映射</p><p><strong>抢占映射空间巨大</strong>？使用采样技术来探索映射空间并快速发现合理的准确近似值。Parcae 应用蒙特卡罗 (MC) 采样。</p><h3 id="迁移策略"><a href="#迁移策略" class="headerlink" title="迁移策略"></a>迁移策略</h3><p>三种迁移策略处理抢占：阶段内迁移、阶段间迁移和管道迁移</p><p><strong>阶段内迁移</strong>：同一阶段有相同的模型参数，当一个实例被抢占时，可以从另一个损坏的管道中的同一阶段转移可用实例</p><p><img src="/../images/Parcae/parcae6.png" alt="img"></p><p>阶段内迁移仅需更新少数实例的通信路由，并且不涉及传输参数。</p><p><strong>阶段间迁移</strong></p><p>如果阶段内迁移不行，进行阶段间迁移</p><p><img src="/../images/Parcae/parcae7.png" alt="img"></p><p>阶段间迁移需要传输模型参数</p><p><strong>管道迁移</strong></p><p><img src="/../images/Parcae/parcae8.png" alt="img"></p><p>需要重新划分模型，涉及大量的迁移开销</p><p>Parcae通过考虑当前并行配置、新的优化并行配置和实际抢占来作出迁移决策</p><p>给定预测抢占的概率映射，Parcae 自动更新最佳并行配置和迁移策略。一旦预测与实际可用性不匹配，Parcae 就会调整并行配置以及相应的迁移策略以进行适应</p><p>当抢占真正发生时，实际的迁移决策才会最终确定，Parcae 利用宽限期（例如，Azure 上的 30 秒）来执行这些迁移。</p><h2 id="liveput优化器"><a href="#liveput优化器" class="headerlink" title="liveput优化器"></a>liveput优化器</h2><p>将liveput最大化表述为一个优化问题，目标是最大化I时间间隔内的训练样本数</p><p>Parcae 使用动态规划算法来探索优化空间并发现并行配置的最佳序列</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>spot实例抢占与parcae预测不匹配怎么办？</p><p>建议的并行配置与可用spot实例不兼容怎么办？</p><p><strong>并行化适配</strong></p><p>当实际可用的spot实例数目大于或者小于预测的数目，parcae会添加或删除数据并行管道，同时保留管道深度。</p><p>当可用的spot实例甚至无法制定单个管道时，它将尝试将管道重新划分为更少的阶段。</p><p><strong>容错能力</strong></p><p>如果同一阶段内所有实例都被抢占，阶段间和阶段内迁移都无法恢复该阶段的状态，parcae使用内存检查点来处理。</p><p>使用多个便宜的按需cpu实例来维护最新的模型状态，通过迭代地将梯度与spot GPU 实例同步来维护最新的检查点，以更新CPU端的模型状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Parcae-Proactive-Liveput-Optimized-DNN-Training-on-Preemptible-Instances&quot;&gt;&lt;a href=&quot;#Parcae-Proactive-Liveput-Optimized-DNN-Training-</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://coolling.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="故障恢复" scheme="https://coolling.github.io/tags/%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/"/>
    
    <category term="NSDI" scheme="https://coolling.github.io/tags/NSDI/"/>
    
    <category term="24年" scheme="https://coolling.github.io/tags/24%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>2923. 找到冠军 I</title>
    <link href="https://coolling.github.io/2024/04/12/2923-%E6%89%BE%E5%88%B0%E5%86%A0%E5%86%9B-I/"/>
    <id>https://coolling.github.io/2024/04/12/2923-%E6%89%BE%E5%88%B0%E5%86%A0%E5%86%9B-I/</id>
    <published>2024-04-12T10:58:59.000Z</published>
    <updated>2024-04-12T11:06:02.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2923-找到冠军-I"><a href="#2923-找到冠军-I" class="headerlink" title="2923. 找到冠军 I"></a>2923. 找到冠军 I</h2><p>最近好忙，抽空摸一题</p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>一场比赛中共有 <code>n</code> 支队伍，按从 <code>0</code> 到 <code>n - 1</code> 编号。</p><p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n * n</code> 的二维布尔矩阵 <code>grid</code> 。对于满足 <code>0 &lt;= i, j &lt;= n - 1</code> 且 <code>i != j</code> 的所有 <code>i, j</code> ：如果 <code>grid[i][j] == 1</code>，那么 <code>i</code> 队比 <code>j</code> 队 <strong>强</strong> ；否则，<code>j</code> 队比 <code>i</code> 队 <strong>强</strong> 。</p><p>在这场比赛中，如果不存在某支强于 <code>a</code> 队的队伍，则认为 <code>a</code> 队将会是 <strong>冠军</strong> 。</p><p>返回这场比赛中将会成为冠军的队伍。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,1],[0,0]]</span><br><span class="line">输出：0</span><br><span class="line">解释：比赛中有两支队伍。</span><br><span class="line">grid[0][1] == 1 表示 0 队比 1 队强。所以 0 队是冠军。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,0,1],[1,0,1],[0,0,0]]</span><br><span class="line">输出：1</span><br><span class="line">解释：比赛中有三支队伍。</span><br><span class="line">grid[1][0] == 1 表示 1 队比 0 队强。</span><br><span class="line">grid[1][2] == 1 表示 1 队比 2 队强。</span><br><span class="line">所以 1 队是冠军。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>2 &lt;= n &lt;= 100</code></li><li><code>grid[i][j]</code> 的值为 <code>0</code> 或 <code>1</code></li><li>对于所有 <code>i</code>，<code> grid[i][i]</code> 等于 <code>0.</code></li><li>对于满足 <code>i != j</code> 的所有 <code>i, j</code> ，<code>grid[i][j] != grid[j][i]</code> 均成立</li><li>生成的输入满足：如果 <code>a</code> 队比 <code>b</code> 队强，<code>b</code> 队比 <code>c</code> 队强，那么 <code>a</code> 队比 <code>c</code> 队强</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>有两种方法：</p><p>1.遍历一遍grid矩阵，看看哪一行元素之和为n-1，这样的时间复杂度为O(n^2^)</p><p>2.打擂台的思想，一个个上去比较，最后留下来的赢家就是胜过所有人的，只需要遍历一遍n，时间复杂度为O(n)</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findChampion</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> win=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(grid[win][i]==<span class="number">0</span>)</span><br><span class="line">                win=i;</span><br><span class="line">        <span class="keyword">return</span> win;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2923-找到冠军-I&quot;&gt;&lt;a href=&quot;#2923-找到冠军-I&quot; class=&quot;headerlink&quot; title=&quot;2923. 找到冠军 I&quot;&gt;&lt;/a&gt;2923. 找到冠军 I&lt;/h2&gt;&lt;p&gt;最近好忙，抽空摸一题&lt;/p&gt;
&lt;h3 id=&quot;题目：&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="简单" scheme="https://coolling.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>OSDI18-Gandiva</title>
    <link href="https://coolling.github.io/2024/04/03/OSDI18-Gandiva/"/>
    <id>https://coolling.github.io/2024/04/03/OSDI18-Gandiva/</id>
    <published>2024-04-03T10:58:59.000Z</published>
    <updated>2024-04-03T11:05:59.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gandiva"><a href="#Gandiva" class="headerlink" title="Gandiva"></a>Gandiva</h1><p>OSDI18</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>a.深度学习作业是计算密集型的，严重依赖GPU；</p><p>b.依赖集群调度程序来确保GPU的高效利用，但是目前使用的是传统专为处理大数据作业使用的集群调度程序；</p><p>c.DLT作业被简单地视为另一个大数据作业，它在作业启动时分配一组 GPU，并在完成之前保留对其 GPU 的独占访问权</p><blockquote><p>高延迟（队头阻塞）和低利用率（作业无法充分利用其分配的 GPU）</p></blockquote><h2 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h2><p>Gandiva，一种新的调度框架，通过根据深度学习工作负载的独特特征定制的调度框架，可以显着提高集群效率</p><h2 id="深度学习特征"><a href="#深度学习特征" class="headerlink" title="深度学习特征"></a>深度学习特征</h2><ul><li>反馈驱动的探索</li></ul><p>用户通常会尝试一个作业的多种配置进行试错（multi-job），使用早期反馈来进行决策【称为超参数搜索，可以是手动的，也可以是自动的】</p><blockquote><p>超参数搜索通常会探索数百种超参数配置，每一轮根据早期反馈（几百个迭代）将低效的配置作业杀掉</p></blockquote><p>而确定了超参数的作业会运行数小时至数天。</p><blockquote><p><strong>这会导致队头阻塞，需要早期反馈的多项作业在队列中等待</strong></p></blockquote><ul><li>DLT作业是异构的，针对的领域不同</li></ul><p>在内存使用、GPU利用率、带宽需求、GPU之间的关联、其他作业的干扰等方面不同</p><p><img src="/../images/Gandiva/gandiva-1.png" alt="关联"></p><blockquote><p><strong>将作业视为黑匣子的传统调度程序将实现次优的集群效率</strong></p></blockquote><ul><li>作业内的可预测性</li></ul><p>一个作业由数百万个相似小批次迭代组成</p><p><img src="/../images/Gandiva/gandiva-2.png" alt="相似"></p><p>【例如，DLT 作业的 GPU RAM 使用遵循与小批次边界对齐的循环模式。前向传递期间内存增加，后向传递期间内存减少。使用的最大和最小 GPU 内存分别为 23GB 和 0.3GB，即 77 倍。该比率随小批次大小而变化】</p><blockquote><p><strong>Gandiva 利用这种循环可预测性来实现高效的应用程序感知时间切片：</strong>DLT 作业可以自动拆分为小批次迭代，并且这些 60 秒以上迭代的集合作为微任务，形成调度间隔；在内存占用最少时执行挂起，显著减小从 GPU 复制并保存在 CPU 中的内存量</p><p><strong>Gandiva使用小批次进度来不断反思其决策，以提高集群效率：</strong>将通信密集型作业动态迁移到更关联的 GPU；动态增加&#x2F;缩小作业的并行度</p></blockquote><h2 id="Gandiva设计"><a href="#Gandiva设计" class="headerlink" title="Gandiva设计"></a><strong>Gandiva设计</strong></h2><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>a.Gandiva 允许传入作业与现有作业分时 GPU，而不是等待当前作业结束。</p><p>使用专为 DLT 作业定制的自定义<strong>挂起-恢复suspend-resume</strong>机制以及<strong>选择性打包</strong>来实现的</p><p>b.Gandiva 支持 DLT 作业从一组 GPU 高效<strong>迁移</strong>到另一组 GPU</p><p>进行碎片整理</p><p>c.Gandiva 支持 <strong>GPU 增长-收缩</strong>机制，以便可以使用空闲 GPU</p><p>d.Gandiva 通过不断<strong>分析</strong> DLT 作业的资源使用情况并评估其性能来<strong>反思</strong></p><ul><li><strong>机制1:suspend-resume</strong></li></ul><blockquote><p>利用现代操作系统支持 CPU 进程时间切片的高效挂起&#x2F;恢复，并添加了对 GPU 时间切片的自定义支持</p></blockquote><p>DLT 作业对 GPU 内存的使用具有循环模式，最小和最大内存使用量之间的差异高达 77 倍。【在 GPU 内存使用率最低时挂起作业】</p><p>（<strong>suspend-resume小模型花费小于100ms，大模型大概1s，给定 1 分钟的时间切片间隔，这相当于 2% 或更少的开销</strong>）</p><ul><li><strong>机制2:packing</strong></li></ul><p>在 GPU 上同时运行多个 DLT 作业。仅当打包的作业不超出 GPU 资源（核心、内存）并且不会相互产生不利影响时，GPU 中的打包才是高效的。</p><ul><li><strong>机制3:迁移</strong></li></ul><p>更改分配给 DLT 作业的 GPU 集</p><blockquote><p>将时间切片作业移动到集群中空出的GPU；将相互干扰的作业迁移出去；对集群进行碎片整理，以便传入的作业获得具有良好局部性的 GPU。</p></blockquote><p><strong>评估两种方法：</strong></p><p>1.<strong>通用进程迁移机制，如CRIU</strong>（<span style="color: rgb(77, 77, 77)"><span style="background-color: rgb(255, 255, 255)">可以冻结一个正在运行的程序，并且checkpoint它到一系列的文件，然后你就可以使用这些文件在任何主机重新恢复这个程序到被冻结的那个点(白话就是实现对已运行程序的备份和恢复)</span></span>）</p><p>由于 CRIU 本身不支持使用 GPU 设备的进程迁移，因此首先checkpoint GPU 对象并在调用 CRIU 之前从进程中删除所有 GPU 状态。</p><p>checkpoint大小在GB级别，单GPU迁移开销为8-10s</p><p>2.<strong>在迁移之前预热目的地并且仅迁移必要的训练状态</strong></p><p>迁移开销只需1-2s</p><blockquote><p>无论哪种方法，服务器间迁移的开销是值得的</p></blockquote><ul><li><strong>机制4:增长-收缩GPU</strong></li></ul><p>根据负载动态增加&#x2F;减少作业可用的GPU数量</p><p>仅将此机制应用于那些明确声明其足以利用这些增长GPU的 DLT 作业</p><ul><li><strong>机制5:分析</strong></li></ul><p>Gandiva 监控资源使用情况，例如 CPU 和 GPU 利用率、CPU&#x2F;GPU 内存等；<strong>内省 DLT 作业，以估计其进度</strong></p><p>Gandiva 估计 DLT 作业的小批次时间，会在调度决策之前和之后比较 DLT 的小批次时间，以确定其有效性（比如说发现打包策略低效，就不打包他们，恢复到suspend-resume机制）</p><h3 id="调度策略：怎么使用上面的机制？"><a href="#调度策略：怎么使用上面的机制？" class="headerlink" title="调度策略：怎么使用上面的机制？"></a>调度策略：怎么使用上面的机制？</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h4><p>作业被封装在容器中：包括所需 GPU 的数量及其优先级以及一个指示作业是否能够增长或收缩的标志</p><p>height：M&#x2F;N，M 是分配的 GPU 数量，N 是 GPU 总数。当height超过1，启动suspend-resume机制。集群的height定义为其所有服务器的最大height。</p><p>服务器的关联affinity：最初为零，如果将需要两个 GPU 的作业分配给服务器，则该服务器的关联affinity将更改为 2。调度程序使用此参数将具有相似 GPU 要求的作业分配给同一服务器。</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong>目标</strong></h4><p>主要设计目标是为作业提供早期反馈。第二个设计目标是集群效率。</p><h4 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a><strong>两种模式</strong></h4><p>可以同时在两种模式下运行</p><p><strong>1.reactive反应模式</strong>：指的是调度程序对作业到达、离开、机器故障等事件做出反应</p><p><strong>a.当新作业到达时</strong>，调度程序会为该作业分配服务器&#x2F;GPU。</p><p>Gandiva 尝试找到与新作业具有相同affinity的节点，且其height小于 1，则分配该节点。否则，Gandiva 尝试查找并分配affinity为0节点。如果没有这样的空闲服务器可用，Gandiva忽略关联性。</p><p>如果以上都没有，说明没有空闲GPU可用，则使用suspend-resume机制，如果存在具有相同affinity的节点，则使用suspend-resume，否则作业将排队</p><p><strong>b.Gandiva中，检查集群的height是否可以降低</strong></p><p>将挂起的作业迁移到新腾出的 GPU 上。</p><p><strong>2..introspective内省模式</strong>：一个连续的过程，其中调度程序旨在提高集群利用率</p><p><strong>a.packing打包</strong>，在过载时才考虑打包</p><p>如果打包作业的​​内存需求组合高于 GPU 内存，则 CPU 内存“分页”的开销会非常高 ，从而导致打包无效。</p><p>当两个或多个作业的内存需求小于 GPU 内存时，打包仍然可能不会比suspend-resume更有效。比如说作业之间的干扰。</p><p><strong>如何确定是否打包？</strong></p><blockquote><p>当作业到达时，suspend-resume模式运行，并收集分析信息（GPU 利用率、内存和作业进度）。</p><p>调度程序维护按 GPU 利用率排序的作业列表。</p><p>选择GPU利用率最低的作业将它打包在利用率最低的GPU（仅当打包作业的​​组合内存利用率不超过 GPU 的总内存时）。</p><p>当打包作业的​​总吞吐量大于时间切片模式时，打包被视为成功。如果不成功就取消打包</p></blockquote><p><strong>b.迁移</strong></p><p>使用迁移改善作业局部性</p><p><img src="/../images/Gandiva/gandiva-3.png" alt="迁移"></p><p>（三分钟后，后台训练作业 DeepSpeech 完成并释放其 8 个 GPU。）</p><p>整理资源碎片：在所有非空闲服务器中选择具有最多空闲 GPU 的服务器。将该服务器上运行的作业转移到其他服务器上。</p><p>重复此操作，直到每个非空闲服务器上的可用 GPU 数量小于阈值（在作者实验中为 4 个中的 3 个），或者没有作业将从迁移中受益。</p><p><strong>c.增长-收缩grow-shrink</strong></p><p>仅当集群未充分利用并且 DLT 作业明确将自己标识为适合增长-收缩时，才会触发增长-收缩。只会增加作业以使用单个服务器中可用的最大 GPU 数量。</p><p><strong>d.时间切片</strong></p><p>支持每个服务器中的循环调度，以公平地共享 GPU 时间</p><p>当作业具有多个优先级时，较高优先级的作业将永远不会被暂停以容纳较低优先级的作业。</p><p>如果服务器已被较高优先级作业充分利用，则较低优先级作业将迁移到另一台服务器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Gandiva&quot;&gt;&lt;a href=&quot;#Gandiva&quot; class=&quot;headerlink&quot; title=&quot;Gandiva&quot;&gt;&lt;/a&gt;Gandiva&lt;/h1&gt;&lt;p&gt;OSDI18&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;header</summary>
      
    
    
    
    <category term="论文阅读" scheme="https://coolling.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="集群调度" scheme="https://coolling.github.io/tags/%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/"/>
    
    <category term="OSDI" scheme="https://coolling.github.io/tags/OSDI/"/>
    
    <category term="18年" scheme="https://coolling.github.io/tags/18%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>331. 验证二叉树的前序序列化</title>
    <link href="https://coolling.github.io/2024/04/01/331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://coolling.github.io/2024/04/01/331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-04-01T09:21:50.000Z</published>
    <updated>2024-04-01T09:50:40.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="331-验证二叉树的前序序列化"><a href="#331-验证二叉树的前序序列化" class="headerlink" title="331. 验证二叉树的前序序列化"></a>331. 验证二叉树的前序序列化</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>序列化二叉树的一种方法是使用 <strong>前序遍历</strong> 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p><strong>保证</strong> 每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p><p>你可以认为输入格式总是有效的</p><ul><li>例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</li></ul><p><strong>注意：</strong>不允许重建树。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = &quot;9,#,#,1&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 104</code></li><li><code>preorder</code> 由以逗号 <code>“，”</code> 分隔的 <code>[0,100]</code> 范围内的整数和 <code>“#”</code> 组成</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题我是看了题解的思路才会的ww菜菜</p><p>a.首先，这道题是给出一个前序序列进行验证是否是正确的前序序列。</p><p>b.如何验证呢？模拟前序序列重建的过程。首先要明白前序遍历是一个dfs的过程，所以这里我们要用栈来进行处理。每处理一层，就将该层剩余的槽位数推入栈中。一开始我们先往栈中推入一个1，代表第一层有一个为根节点准备的空槽位，之后开始遍历这个前序序列。如果这个栈顶的数字为0，则一直pop，直到找到一个栈顶不为0的数，这个过程也是模拟的前序遍历dfs时回退的过程。如果当前遍历的是‘#’，则栈顶数字减一，代表这一层的空槽位减一；如果不为‘#’，则栈顶数字减一，并且再往栈中推入一个2，因为如果当前读到的不是个空节点，那么他肯定还有下一层，根据dfs的特性，我们要先处理这个更深一层的节点，所以把他推入栈中。</p><p>c.如果题目是验证后序遍历呢？那么和前序遍历是一样的，只是从这个序列的后面开始遍历这个字符串</p><p>d.如果题目是验证中序遍历呢？发现中序遍历的序列结果全是“#x#x#x#x#”这种形式的，x代表数字。思考了一下为什么会这样。当我们从左到右处理这个中序序列时，除了读入的第一个字符，之后的字符，要么是来当目前子树的父节点的，要么是要加入一个右节点的，而根节点必然是个x，而右节点必然是个#，因为如果我们挂上了一个x在某个右节点，此时这个x节点必然有一个悬空的左节点，但在中序序列的遍历中，我们不会为他挂上左节点，导致这棵树不能成为真正的树。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSerialization</span><span class="params">(string preorder1)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; preorder;</span><br><span class="line">        <span class="type">int</span> n=preorder1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> last=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder1[i]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                preorder.<span class="built_in">push_back</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                last=<span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(preorder1[i]==<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(last==<span class="literal">true</span>)&#123;</span><br><span class="line">                    preorder.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                last=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last==<span class="literal">true</span>)&#123;</span><br><span class="line">            preorder.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        n=preorder.<span class="built_in">size</span>();</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">        re.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!re.<span class="built_in">empty</span>()&amp;&amp;t&lt;n)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(re.<span class="built_in">top</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">                re.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(re.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(re.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> q=re.<span class="built_in">top</span>();</span><br><span class="line">            re.<span class="built_in">pop</span>();</span><br><span class="line">            re.<span class="built_in">push</span>(q<span class="number">-1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(preorder[t]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                re.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            t++;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t&lt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(re.<span class="built_in">top</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;331-验证二叉树的前序序列化&quot;&gt;&lt;a href=&quot;#331-验证二叉树的前序序列化&quot; class=&quot;headerlink&quot; title=&quot;331. 验证二叉树的前序序列化&quot;&gt;&lt;/a&gt;331. 验证二叉树的前序序列化&lt;/h2&gt;&lt;h3 id=&quot;题目：&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="算法" scheme="https://coolling.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://coolling.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://coolling.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="栈" scheme="https://coolling.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
</feed>
